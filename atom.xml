<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://philosopherzb.github.io</id>
    <title>Philosopher</title>
    <updated>2023-02-27T09:00:58.887Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://philosopherzb.github.io"/>
    <link rel="self" href="https://philosopherzb.github.io/atom.xml"/>
    <subtitle>WORLD AS CODE</subtitle>
    <logo>https://philosopherzb.github.io/images/avatar.png</logo>
    <icon>https://philosopherzb.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Philosopher</rights>
    <entry>
        <title type="html"><![CDATA[Java多线程基础]]></title>
        <id>https://philosopherzb.github.io/post/java-duo-xian-cheng-ji-chu/</id>
        <link href="https://philosopherzb.github.io/post/java-duo-xian-cheng-ji-chu/">
        </link>
        <updated>2020-12-18T08:13:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="多线程基础">多线程基础</h2>
<h3 id="java多线程并发库">java多线程并发库</h3>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230227001.png" alt="img" loading="lazy"></figure>
<h3 id="进程与线程">进程与线程</h3>
<p>进程：是程序运行以及资源分配的基本单位，一个程序至少有一个进程。</p>
<p>线程：是CPU调度和分配的基本单位，一个进程至少有一个线程。同一个进程中的线程共享其资源（减少切换，可提高效率），且可以并发执行（并发：同一时间间隔可以做多件事；并行：同一时刻可以做多件事（多核））。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230227002.png" alt="img" loading="lazy"></figure>
<h3 id="线程的上文切换">线程的上文切换</h3>
<ul>
<li>一个CPU核在任意时刻只能执行一个线程，如果有多个线程（超过CPU核数）存在，CPU将会采用时间片轮转的方式进行线程切换，即给每一个线程分配一个时间片，当一个线程的时间片用完的时候便会处于就绪状态，并让出CPU给其他线程使用，这就是一次上下文切换。</li>
<li>上下文切换时是通过运行时数据区中的程序计数器来存储各个线程的运行状态的，以便于下次运行线程时可以接着上次指令继续运行（比如线程A做了一次计算准备返回数据时，切换到了线程B，然后又切回线程A，是直接返回数据，而不是再去计算一遍）。</li>
<li>程序计数器指的是JVM中的一块内存区域，它可以看作是当前线程所执行字节码的行号指示器，通过它，Java可以知道每个线程执行到了哪一步指令（由此可以看出程序计数器是线程私有的）。</li>
<li>一般而言，上下文切换是比较耗费CPU时间的一种操作。</li>
</ul>
<h3 id="线程的几种状态">线程的几种状态</h3>
<ul>
<li>创建：指的是生成线程对象，此时并没有调用start方法。</li>
<li>就绪：调用线程的start方法后，线程便进入了就绪状态，此时等待系统调度。</li>
<li>运行：通过系统调度，开始运行线程中的run函数。</li>
<li>等待：调用了Object.wait()会进入等待队列。一般需要等待其他线程做出一些特定的通知或者中断。</li>
<li>超时等待：该状态与等待状态有一点区别就是它会自动返回，比如调用Threa.sleep(long)，在超时之后，会自动返回进入就绪状态。</li>
<li>阻塞：指的是去获取锁时(等待进入synchronized方法或块)，发现同步锁被占用了，这时线程会被放入锁池，等待获取锁。</li>
<li>死亡：运行完run方法，main方法（main方法指的是主线程）之后正常退出，也有可能出现异常导致死亡；死亡的线程不能重新启用，否则报错。</li>
</ul>
<h2 id="创建线程的几种方式">创建线程的几种方式</h2>
<h3 id="继承thread">继承Thread</h3>
<pre><code>public class ThreadTest {
    public static void main(String[] args){
        new TestThread().start();
    }
}

class TestThread extends Thread{
    @Override
    public void run(){
        System.out.println(&quot;Test Thread&quot;);
    }
}
</code></pre>
<h3 id="实现runnable">实现Runnable</h3>
<pre><code>public class ThreadTest {
    public static void main(String[] args){
        new Thread(new TestRunnable()).start();
    }
}

class TestRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println(&quot;Test Runnable&quot;);
    }
}
</code></pre>
<h3 id="实现callable">实现Callable</h3>
<pre><code>public class ThreadTest {
    public static void main(String[] args){
        FutureTask&lt;Integer&gt; task = new FutureTask(new TestCallable());
        new Thread(task).start();
        try {
            System.out.println(task.get());//get方法会得到call执行完之后的值
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

class TestCallable implements Callable&lt;Integer&gt; {
    @Override
    public Integer call() throws Exception {
        int num = 0;
        while(num &lt; 5){
            num++;
        }
        return num;
    }
}
</code></pre>
<h2 id="线程安全性">线程安全性</h2>
<ul>
<li>原子性：同一时刻只允许一个线程对数据进行操作（atomic开头的原子类,synchronized，Lock）。</li>
<li>可见性：一个线程对共享变量的修改，可以及时地被其他线程观察到，（synchronized,volatile，Lock）。</li>
<li>有序性：指的是可以观察到其他线程的指令执行顺序，由于指令重排，一般情况下是无序的（happens-before原则）。</li>
</ul>
<h3 id="线程死锁">线程死锁</h3>
<h4 id="死锁">死锁</h4>
<ul>
<li>指的是多个线程在执行过程中，因争夺资源而陷入环路阻塞的一种现象。</li>
<li>示例代码如下（运行之后，两个线程陷入死锁中，如果没有外力中断，将会一直锁定）：</li>
</ul>
<pre><code>public class ThreadTest {
    //共享资源A
    private static final Object A = new Object();
    //共享资源B
    private static final Object B = new Object();

    public static void main(String[] args){
        new Thread(() -&gt; {
            synchronized (A){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---B&quot;);
                synchronized (B){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                }
            }
        },&quot;Thread-01&quot;).start();

        new Thread(() -&gt; {
            synchronized (B){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---A&quot;);
                synchronized (A){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                }
            }
        },&quot;Thread-02&quot;).start();
    }
}
</code></pre>
<h4 id="死锁四个必要条件以及如何避免死锁">死锁四个必要条件以及如何避免死锁</h4>
<ul>
<li>互斥条件：一个资源在任意时刻只能被一个线程占用，如果有其他线程请求该资源，需要等待原线程释放资源（此条件不能被破坏，因为锁本身就是为了互斥访问）。</li>
<li>请求和保持条件：一个线程已经获取了一部分资源，又去请求其他资源，如果其他资源正被占用，原线程陷入阻塞，且不会释放自己占用的资源（一次性申请所有资源；或者阻塞时，释放自己占用的资源）。</li>
<li>不可剥夺条件：一个线程已经获得的资源，在自己未使用完之前不能被其他线程剥夺，只能自己使用结束后释放（如果去获取正在被其他线程使用的资源而阻塞时，可以释放自己占用的资源）。</li>
<li>环路等待条件：多个进程之间形成一种头尾相接的循环等待资源关系（按一定的顺序来获取资源）。</li>
<li>针对上述例子而言，可以让现线程1先获取资源AB，执行完之后，再让线程2获取资源AB，改动如下（执行顺序为：线程1先获取资源A，接着释放CPU，线程2执行准备去获取资源A，发现资源A已被占用，此时线程2阻塞，然后一秒之后释放CPU，线程1接着执行，去获取资源B，正常获取，执行完毕，释放CPU；线程2开始获取资源A，由于线程1已经执行完毕释放了锁，所以线程2正常获取资源A，接着休眠一秒释放CPU，然后又去获取资源B，同样正常获取，执行完毕）：</li>
</ul>
<pre><code>public class ThreadTest {
    //共享资源A
    private static final Object A = new Object();
    //共享资源B
    private static final Object B = new Object();

    public static void main(String[] args){
        new Thread(() -&gt; {
            synchronized (A){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---B&quot;);
                synchronized (B){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                }
            }
        },&quot;Thread-01&quot;).start();

        new Thread(() -&gt; {
            //线程2去获取A时被阻塞
            synchronized (A){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---B&quot;);
                synchronized (B){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                }
            }
        },&quot;Thread-02&quot;).start();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础知识]]></title>
        <id>https://philosopherzb.github.io/post/java-ji-chu-zhi-shi/</id>
        <link href="https://philosopherzb.github.io/post/java-ji-chu-zhi-shi/">
        </link>
        <updated>2020-10-14T07:12:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="面向对象的三大特性">面向对象的三大特性</h2>
<h3 id="封装">封装</h3>
<ul>
<li>将现实中的客观事物封装成抽象的类。</li>
<li>对一个类中的变量，方法进行访问符修饰，以达到有些变量，方法对外开放，有些变量，方法隐藏。</li>
<li>针对第2点对应的访问修饰符有(范围从大到小)：public &gt; protected &gt; default &gt; private。</li>
<li>由于封装隐藏了具体实现，仅提供接口供外部调用，所以在一定程度上可以提高安全性。</li>
</ul>
<h3 id="继承">继承</h3>
<ul>
<li>可以实现已存在的类的变量，方法（非private），并可以扩展单属于自我的变量及方法。</li>
<li>继承在Java中为单继承，即一个子类只能继承一个父类（可以实现多个接口）。</li>
<li>通过继承创建的类称为“子类”，“派生类”。</li>
<li>被继承的类称为“父类”，“基类”，“超类”。</li>
<li>继承的关系是is-a，比如说老师是人，狮子是动物等。</li>
<li>继承可以降低代码的重复性，方便后续对公共行为的维护，不过同时也增加了代码的耦合度。</li>
<li>子类不继承父类的构造器，而是显示或隐式的调用（如果父类中存在不带参构造器，则子类隐式调用该构造器；否则如果父类中仅存在带参构造器，则子类需要通过super来显示调用父类带参构造器）。</li>
</ul>
<h3 id="多态">多态</h3>
<ul>
<li>对同一个行为体现出不同的表现形式，比如吃，可以吃饭，吃零食等。</li>
<li>在Java中体现为对方法的重写以及重载，即传入参数来决定做哪一种具体的动作（重载）不同类之间同一方法不同表现（重写）。</li>
<li>重写一般为父子类之间对方法的不同操作，重载一般为同一个类中对方法的不同操作。</li>
</ul>
<h2 id="基本数据类型四个整数两个浮点一个字符一个布尔">基本数据类型（四个整数，两个浮点，一个字符，一个布尔）</h2>
<ul>
<li>byte，占8位，1字节，默认值：0，包装类：java.lang.Byte</li>
<li>short，占16位，2字节，默认值：0，包装类：java.lang.Short</li>
<li>int，占32位，4字节，默认值：0，包装类：java.lang.Integer</li>
<li>long，占64位，8字节，默认值：0L，包装类：java.lang.Long</li>
<li>float，占32位，4字节，默认值：0.0f，包装类：java.lang.Float</li>
<li>double，占64位，8字节，默认值：0.fd，包装类：java.lang.Double</li>
<li>char，可以存储任何字符，包装类：java.lang.Character</li>
<li>boolean，默认值：false，包装类：java.lang.Boolean</li>
</ul>
<h2 id="面向对象的六大基本原册">面向对象的六大基本原册</h2>
<h3 id="单一职责原则single-responsibility-priciple">单一职责原则（Single Responsibility Priciple）</h3>
<ul>
<li>对于一个类而言，应该只有一个引起他变化的原因。</li>
<li>比如，不要将teacher,doctor都放在一个person类中，而是将其拆成teacher类，doctor类。</li>
<li>能够一定程度上降低耦合度。</li>
</ul>
<h3 id="开闭原则open-close-priciple">开闭原则（Open Close Priciple）</h3>
<ul>
<li>对于扩展是开放的，对于修改是关闭的。</li>
<li>一般来说就是不要修改之前的代码，可以选择继承或者实现接口来扩展对应的功能。</li>
</ul>
<h3 id="里式替换原则liskov-substitution-priciple">里式替换原则（Liskov Substitution Priciple）</h3>
<ul>
<li>所有引用父类的地方都可以透明的使用其子类对象。</li>
<li>即父类出现的地方，把父类换成子类不会出现异常或错误；反之，子类出现的地方，把子类换成父类可能会出现异常或错误。</li>
<li>比如,person类具有eat功能，那么将person.eat换成teacher.eat是没有问题的；而如果teacher类具有独特的teach功能，那么如果将teacher.teach换成person.teach就会出现错误。</li>
</ul>
<h3 id="依赖倒置原则dependence-inversion-priciple">依赖倒置原则（Dependence Inversion Priciple）</h3>
<ul>
<li>高层模块不依赖低层模块，而是应该依赖其抽象</li>
<li>抽象不依赖于细节，细节依赖于抽象</li>
<li>比如teacher类中应该尽量做一些老师共有的抽象行为，比如教书，这样后面的语文老师，数学老师等可以继承该抽象老师类进行扩展。</li>
</ul>
<h3 id="接口隔离原则interface-segregation-priciple">接口隔离原则（Interface Segregation Priciple）</h3>
<ul>
<li>客户端不应该依赖它不需要的接口;一个类对另一个类的依赖应该建立在最小的接口上</li>
<li>尽量一个接口只实现一个功能，如果接口功能太多可进行拆分。</li>
</ul>
<h3 id="迪米特原则law-of-demeter-or-least-knowlegde-priciple">迪米特原则（Law of Demeter or Least Knowlegde Priciple）</h3>
<ul>
<li>一个对象应该对其他对象有最少的了解。</li>
<li>此原则与接口隔离原则可以结合使用，尽量保持一个方法一个具体行为，而不要涵盖多个行为。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://philosopherzb.github.io/post/hello-gridea/</id>
        <link href="https://philosopherzb.github.io/post/hello-gridea/">
        </link>
        <updated>2020-09-03T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typora]]></title>
        <id>https://philosopherzb.github.io/post/typora/</id>
        <link href="https://philosopherzb.github.io/post/typora/">
        </link>
        <updated>2019-09-03T05:41:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="welcome">Welcome</h2>
<p>Thank you for choosing <strong>Typora</strong>. This document will help you to start Typora. Please note that Typora for Windows is still in beta phase, so this document may be updated in future version-ups.</p>
<h2 id="live-preview">Live Preview</h2>
<p><strong>Typora</strong> use the feature: <em>Live Preview</em>, meaning that you could see these inline styles after you finish typing, and see block styles when you type or after you press <code>Enter</code> key or focus to another paragraph. Just try to type some markdown in typora, and you would see how it works.</p>
<p><strong>Note</strong>: Markdown tags for inline styles, such as <code>**</code> will be hidden or displayed smartly. Markdown tags for block level styles, such as <code>###</code> or <code>- [x]</code> will be hidden once the block is rendered.</p>
<p>You could switch to source code mode temporary from menu bar, footer bar or short cut key (<code>ctrl+/</code>). But we only provide very basic support for source code mode and won't recommend users to do so.</p>
<h2 id="markdown-for-typora">Markdown For Typora</h2>
<p><strong>Typora</strong> is using <a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown</a> .</p>
<p>To see full markdown Syntax references and extra usage, please check <code>Help</code>-&gt;<code>Markdown Reference</code> in menu bar or <code>About</code> panel.</p>
<h2 id="shortcut-keys">Shortcut Keys</h2>
<p>You could find shortcut keys in the right side of menu items from menu bar.For more shortcut key details and custom key bindings, you can refer <a href="http://support.typora.io/Shortcut-Keys/">here</a>.</p>
<h2 id="copy">Copy</h2>
<p>We create typora and want to make it your default markdown editor, thus copy and paste means copy from another app or paste to another app, instead of <em>copy/paste from/to another markdown editor</em>. Therefore, by default, <code>Copy</code> means <code>Copy As HTML</code> ( and <code>Paste</code> means <code>Paste from HTML</code>).</p>
<p>However, after click &quot;<strong>Copy Markdown source by default</strong>&quot;, typora will copy selected text in HTML/markdown format (When pasting, rich editors will accept the HTML format, while plain text / code editor will accept the markdown source code format).</p>
<p>To <strong>copy Markdown source code</strong> explicitly, please use shortcut key <code>shift+cmd+c</code> or <code>Copy as Markdown</code> from menu. To <strong>Copy as HTML Code</strong>, please select <code>Copy as HTML Code</code> from menu.</p>
<h2 id="smart-paste">Smart Paste</h2>
<p><strong>Typora</strong> is able to analyze styles of the text content in your clipboard when pasting. For example, after pasting a <code>&lt;h1&gt;HEADING&lt;/h1&gt;</code> from some website, typora will keep the 'first level heading’ format instead of paste ‘heading’ as plain text.</p>
<p>To <strong>paste as markdown source</strong> or plain text, you should use <code>paste as plain text</code> or press the shortcut key: <code>shift+cmd+v</code>.</p>
<h2 id="themes">Themes</h2>
<p>Please refer to <code>Help</code> → <code>Custom Themes</code> from menu bar.</p>
<h2 id="publish">Publish</h2>
<p>Currently Typora only support to export as <strong>PDF</strong> or <strong>HTML</strong>. More data format support as import/export will be integrated in future.</p>
<h2 id="auto-save-and-file-recovery">Auto Save and File Recovery</h2>
<p>Typora support  auto save feature, user could enable it from preference panel.</p>
<p>Typora does not provide professional version control and file backup feature, but typora would backup the last file content from time to time automatically, so even when typora crashes or users forget to save the file before close, it is possible to recovery most of the work by clicking <code>Recovery Unsaved Drafts</code> from preference folder, and copy out backed-up files. The File name in this folder is consists of last saved date, originally file name and last saved timestamp.</p>
<h2 id="more-useful-tips-documents">More Useful Tips &amp; Documents</h2>
<p><a href="https://support.typora.io/">https://support.typora.io/</a></p>
<h2 id="and-more">And More ?</h2>
<p>For more questions or feedbacks, please contact us by:</p>
<ul>
<li>Home Page: http://typora.io</li>
<li>Email: <a href="mailto:hi@typora.io">hi@typora.io</a></li>
<li>Twitter <a href="https://twitter.com/typora">@typora</a></li>
</ul>
<p>We opened a Github issue page in case you want to start a discussion or as an alternative way to report bugs/suggestions: https://github.com/typora/typora-issues/issues</p>
]]></content>
    </entry>
</feed>