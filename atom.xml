<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://philosopherzb.github.io</id>
    <title>Philosopher</title>
    <updated>2023-02-28T08:34:44.680Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://philosopherzb.github.io"/>
    <link rel="self" href="https://philosopherzb.github.io/atom.xml"/>
    <subtitle>WORLD AS CODE</subtitle>
    <logo>https://philosopherzb.github.io/images/avatar.png</logo>
    <icon>https://philosopherzb.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Philosopher</rights>
    <entry>
        <title type="html"><![CDATA[Java线程池详解]]></title>
        <id>https://philosopherzb.github.io/post/java-xian-cheng-chi-xiang-jie/</id>
        <link href="https://philosopherzb.github.io/post/java-xian-cheng-chi-xiang-jie/">
        </link>
        <updated>2021-01-09T05:49:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程池">线程池</h2>
<h3 id="线程池的优势">线程池的优势</h3>
<ul>
<li>降低系统资源消耗：通过重用已存在的线程，降低线程创建和销毁所造成的资源消耗。</li>
<li>提供系统响应速度：当任务来临时，直接复用已存在的线程进行工作，而无需等待线程的创建。</li>
<li>方便线程数的管控：过多的线程创建，会导致性能的急剧下降（线程上下文切换十分耗费性能），甚至出现OOM。</li>
<li>提供更加强大的功能，如延时定时线程池。</li>
</ul>
<h3 id="线程池的主要参数">线程池的主要参数</h3>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
</code></pre>
<ul>
<li>corePoolSize：核心线程数，默认情况下，核心线程一直存活在线程池中，即使它们处于闲置状态（可通过allowCoreThreadTimeOut进行控制）。当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会创建一个新的线程来执行任务，直到创建的线程数大于或等于corePoolSize时才进行线程复用（可通过prestartCoreThread()或者prestartAllCoreThreads()来提前启动线程池中的基本线程）。</li>
<li>maximumPoolSize：最大线程数，当队列满了，且已创建线程数小于maximumPoolSize时，线程池会创建新的线程来执行任务。</li>
<li>keepAliveTime：线程闲置时长，超过此时长将会被销毁。默认只对非核心线程生效，只有当ThreadPoolExecutor中的allowCoreThreadTimeOut设置为true时，才会对核心线程生效。</li>
<li>unit：用于指定keepAliveTime参数的时间单位。</li>
<li>workQueue：工作队列，用于保存等待执行的任务的阻塞队列。通过线程池的execute方法提交的Runnable对象都会存储在该队列中。</li>
</ul>
<ol>
<li>ArrayBlockingQueue：基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</li>
<li>LinkedBlockingQueue：基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</li>
<li>SynchronousQueue：内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于SynchronousQueue中的数据元素只有当我们试着取走的时候才可能存在。</li>
<li>PriorityBlockingQueue：具有优先级的无限阻塞队列。</li>
<li>通过实现BlockingQueue接口来自定义所需要的阻塞队列</li>
</ol>
<ul>
<li>threadFactory：线程工厂，用于创建新线程。</li>
<li>handler：拒绝策略，当线程池饱和时（任务队列以及活动线程数都已达到最大值），此时便会执行对应的拒绝策略。</li>
</ul>
<ol>
<li>CallerRunsPolicy：使用调用者所在线程来运行任务。</li>
<li>AbortPolicy：直接抛出RejectedExecutionException异常。</li>
<li>DiscardPolicy：丢弃掉该任务，不进行处理</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
</ol>
<h3 id="线程池流程图">线程池流程图</h3>
<ol>
<li>如果在线程池中的线程数量没有达到核心线程数量，这时候就会启动一个核心线程来执行任务（等于核心线程数时，会复用线程池中已存在的线程）。</li>
<li>如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。</li>
<li>由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值（maximumPoolSize），那么这时候就会立即启动一个非核心线程来执行任务。</li>
<li>如果线程池中的数量达到了所规定的最大值（maximumPoolSize），那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230228001.png" alt="img" loading="lazy"></figure>
<h3 id="四种线程池一般不推荐使用">四种线程池（一般不推荐使用）</h3>
<p>1、newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换），无界线程池，容易发生OOM。</p>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}

</code></pre>
<p>2、newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）</p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}

</code></pre>
<p>3、newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。</p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}

</code></pre>
<p>4、newScheduledThreadPool：适用于执行延时或者周期性任务.</p>
<pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
//实例：
ScheduledExecutorService service = Executors.newScheduledThreadPool(4);
service.schedule(() -&gt; System.out.println(Thread.currentThread().getName()+&quot;延迟三秒执行&quot;), 3, TimeUnit.SECONDS);
service.scheduleAtFixedRate(() -&gt; System.out.println(Thread.currentThread().getName()+&quot;延迟三秒后每隔2秒执行&quot;), 3, 2, TimeUnit.SECONDS);

</code></pre>
<p>schedule(Runnable command, long delay, TimeUnit unit)：延迟一定时间后执行Runnable任务；</p>
<p>schedule(Callable callable, long delay, TimeUnit unit)：延迟一定时间后执行Callable任务；</p>
<p>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)：延迟一定时间后，以间隔period时间的频率周期性地执行任务(固定频率的含义就是可能设定的固定时间不足以完成线程任务，但是它不管，达到设定的延迟时间了就要执行下一次了)；</p>
<p>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit)：与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔，也就是这一些任务系列的触发时间都是可预知的.</p>
<h3 id="线程池中的线程数配置">线程池中的线程数配置</h3>
<ul>
<li>CPU密集型任务：线程池中线程个数应尽量少，如配置N+1个线程的线程池；</li>
<li>IO密集型任务：由于IO操作速度远低于CPU速度，那么在运行这类任务时，CPU绝大多数 时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高CPU利用率，如2*N；</li>
<li>混合型任务：可以拆分为CPU密集型任务和IO密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java多线程基础]]></title>
        <id>https://philosopherzb.github.io/post/java-duo-xian-cheng-ji-chu/</id>
        <link href="https://philosopherzb.github.io/post/java-duo-xian-cheng-ji-chu/">
        </link>
        <updated>2020-12-18T08:13:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="多线程基础">多线程基础</h2>
<h3 id="java多线程并发库">java多线程并发库</h3>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230227001.png" alt="img" loading="lazy"></figure>
<h3 id="进程与线程">进程与线程</h3>
<p>进程：是程序运行以及资源分配的基本单位，一个程序至少有一个进程。</p>
<p>线程：是CPU调度和分配的基本单位，一个进程至少有一个线程。同一个进程中的线程共享其资源（减少切换，可提高效率），且可以并发执行（并发：同一时间间隔可以做多件事；并行：同一时刻可以做多件事（多核））。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230227002.png" alt="img" loading="lazy"></figure>
<h3 id="线程的上文切换">线程的上文切换</h3>
<ul>
<li>一个CPU核在任意时刻只能执行一个线程，如果有多个线程（超过CPU核数）存在，CPU将会采用时间片轮转的方式进行线程切换，即给每一个线程分配一个时间片，当一个线程的时间片用完的时候便会处于就绪状态，并让出CPU给其他线程使用，这就是一次上下文切换。</li>
<li>上下文切换时是通过运行时数据区中的程序计数器来存储各个线程的运行状态的，以便于下次运行线程时可以接着上次指令继续运行（比如线程A做了一次计算准备返回数据时，切换到了线程B，然后又切回线程A，是直接返回数据，而不是再去计算一遍）。</li>
<li>程序计数器指的是JVM中的一块内存区域，它可以看作是当前线程所执行字节码的行号指示器，通过它，Java可以知道每个线程执行到了哪一步指令（由此可以看出程序计数器是线程私有的）。</li>
<li>一般而言，上下文切换是比较耗费CPU时间的一种操作。</li>
</ul>
<h3 id="线程的几种状态">线程的几种状态</h3>
<ul>
<li>创建：指的是生成线程对象，此时并没有调用start方法。</li>
<li>就绪：调用线程的start方法后，线程便进入了就绪状态，此时等待系统调度。</li>
<li>运行：通过系统调度，开始运行线程中的run函数。</li>
<li>等待：调用了Object.wait()会进入等待队列。一般需要等待其他线程做出一些特定的通知或者中断。</li>
<li>超时等待：该状态与等待状态有一点区别就是它会自动返回，比如调用Threa.sleep(long)，在超时之后，会自动返回进入就绪状态。</li>
<li>阻塞：指的是去获取锁时(等待进入synchronized方法或块)，发现同步锁被占用了，这时线程会被放入锁池，等待获取锁。</li>
<li>死亡：运行完run方法，main方法（main方法指的是主线程）之后正常退出，也有可能出现异常导致死亡；死亡的线程不能重新启用，否则报错。</li>
</ul>
<h2 id="创建线程的几种方式">创建线程的几种方式</h2>
<h3 id="继承thread">继承Thread</h3>
<pre><code>public class ThreadTest {
    public static void main(String[] args){
        new TestThread().start();
    }
}

class TestThread extends Thread{
    @Override
    public void run(){
        System.out.println(&quot;Test Thread&quot;);
    }
}
</code></pre>
<h3 id="实现runnable">实现Runnable</h3>
<pre><code>public class ThreadTest {
    public static void main(String[] args){
        new Thread(new TestRunnable()).start();
    }
}

class TestRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println(&quot;Test Runnable&quot;);
    }
}
</code></pre>
<h3 id="实现callable">实现Callable</h3>
<pre><code>public class ThreadTest {
    public static void main(String[] args){
        FutureTask&lt;Integer&gt; task = new FutureTask(new TestCallable());
        new Thread(task).start();
        try {
            System.out.println(task.get());//get方法会得到call执行完之后的值
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

class TestCallable implements Callable&lt;Integer&gt; {
    @Override
    public Integer call() throws Exception {
        int num = 0;
        while(num &lt; 5){
            num++;
        }
        return num;
    }
}
</code></pre>
<h2 id="线程安全性">线程安全性</h2>
<ul>
<li>原子性：同一时刻只允许一个线程对数据进行操作（atomic开头的原子类,synchronized，Lock）。</li>
<li>可见性：一个线程对共享变量的修改，可以及时地被其他线程观察到，（synchronized,volatile，Lock）。</li>
<li>有序性：指的是可以观察到其他线程的指令执行顺序，由于指令重排，一般情况下是无序的（happens-before原则）。</li>
</ul>
<h3 id="线程死锁">线程死锁</h3>
<h4 id="死锁">死锁</h4>
<ul>
<li>指的是多个线程在执行过程中，因争夺资源而陷入环路阻塞的一种现象。</li>
<li>示例代码如下（运行之后，两个线程陷入死锁中，如果没有外力中断，将会一直锁定）：</li>
</ul>
<pre><code>public class ThreadTest {
    //共享资源A
    private static final Object A = new Object();
    //共享资源B
    private static final Object B = new Object();

    public static void main(String[] args){
        new Thread(() -&gt; {
            synchronized (A){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---B&quot;);
                synchronized (B){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                }
            }
        },&quot;Thread-01&quot;).start();

        new Thread(() -&gt; {
            synchronized (B){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---A&quot;);
                synchronized (A){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                }
            }
        },&quot;Thread-02&quot;).start();
    }
}
</code></pre>
<h4 id="死锁四个必要条件以及如何避免死锁">死锁四个必要条件以及如何避免死锁</h4>
<ul>
<li>互斥条件：一个资源在任意时刻只能被一个线程占用，如果有其他线程请求该资源，需要等待原线程释放资源（此条件不能被破坏，因为锁本身就是为了互斥访问）。</li>
<li>请求和保持条件：一个线程已经获取了一部分资源，又去请求其他资源，如果其他资源正被占用，原线程陷入阻塞，且不会释放自己占用的资源（一次性申请所有资源；或者阻塞时，释放自己占用的资源）。</li>
<li>不可剥夺条件：一个线程已经获得的资源，在自己未使用完之前不能被其他线程剥夺，只能自己使用结束后释放（如果去获取正在被其他线程使用的资源而阻塞时，可以释放自己占用的资源）。</li>
<li>环路等待条件：多个进程之间形成一种头尾相接的循环等待资源关系（按一定的顺序来获取资源）。</li>
<li>针对上述例子而言，可以让现线程1先获取资源AB，执行完之后，再让线程2获取资源AB，改动如下（执行顺序为：线程1先获取资源A，接着释放CPU，线程2执行准备去获取资源A，发现资源A已被占用，此时线程2阻塞，然后一秒之后释放CPU，线程1接着执行，去获取资源B，正常获取，执行完毕，释放CPU；线程2开始获取资源A，由于线程1已经执行完毕释放了锁，所以线程2正常获取资源A，接着休眠一秒释放CPU，然后又去获取资源B，同样正常获取，执行完毕）：</li>
</ul>
<pre><code>public class ThreadTest {
    //共享资源A
    private static final Object A = new Object();
    //共享资源B
    private static final Object B = new Object();

    public static void main(String[] args){
        new Thread(() -&gt; {
            synchronized (A){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---B&quot;);
                synchronized (B){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                }
            }
        },&quot;Thread-01&quot;).start();

        new Thread(() -&gt; {
            //线程2去获取A时被阻塞
            synchronized (A){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---B&quot;);
                synchronized (B){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                }
            }
        },&quot;Thread-02&quot;).start();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础知识]]></title>
        <id>https://philosopherzb.github.io/post/java-ji-chu-zhi-shi/</id>
        <link href="https://philosopherzb.github.io/post/java-ji-chu-zhi-shi/">
        </link>
        <updated>2020-10-14T07:12:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="面向对象的三大特性">面向对象的三大特性</h2>
<h3 id="封装">封装</h3>
<ul>
<li>将现实中的客观事物封装成抽象的类。</li>
<li>对一个类中的变量，方法进行访问符修饰，以达到有些变量，方法对外开放，有些变量，方法隐藏。</li>
<li>针对第2点对应的访问修饰符有(范围从大到小)：public &gt; protected &gt; default &gt; private。</li>
<li>由于封装隐藏了具体实现，仅提供接口供外部调用，所以在一定程度上可以提高安全性。</li>
</ul>
<h3 id="继承">继承</h3>
<ul>
<li>可以实现已存在的类的变量，方法（非private），并可以扩展单属于自我的变量及方法。</li>
<li>继承在Java中为单继承，即一个子类只能继承一个父类（可以实现多个接口）。</li>
<li>通过继承创建的类称为“子类”，“派生类”。</li>
<li>被继承的类称为“父类”，“基类”，“超类”。</li>
<li>继承的关系是is-a，比如说老师是人，狮子是动物等。</li>
<li>继承可以降低代码的重复性，方便后续对公共行为的维护，不过同时也增加了代码的耦合度。</li>
<li>子类不继承父类的构造器，而是显示或隐式的调用（如果父类中存在不带参构造器，则子类隐式调用该构造器；否则如果父类中仅存在带参构造器，则子类需要通过super来显示调用父类带参构造器）。</li>
</ul>
<h3 id="多态">多态</h3>
<ul>
<li>对同一个行为体现出不同的表现形式，比如吃，可以吃饭，吃零食等。</li>
<li>在Java中体现为对方法的重写以及重载，即传入参数来决定做哪一种具体的动作（重载）不同类之间同一方法不同表现（重写）。</li>
<li>重写一般为父子类之间对方法的不同操作，重载一般为同一个类中对方法的不同操作。</li>
</ul>
<h2 id="基本数据类型四个整数两个浮点一个字符一个布尔">基本数据类型（四个整数，两个浮点，一个字符，一个布尔）</h2>
<ul>
<li>byte，占8位，1字节，默认值：0，包装类：java.lang.Byte</li>
<li>short，占16位，2字节，默认值：0，包装类：java.lang.Short</li>
<li>int，占32位，4字节，默认值：0，包装类：java.lang.Integer</li>
<li>long，占64位，8字节，默认值：0L，包装类：java.lang.Long</li>
<li>float，占32位，4字节，默认值：0.0f，包装类：java.lang.Float</li>
<li>double，占64位，8字节，默认值：0.fd，包装类：java.lang.Double</li>
<li>char，可以存储任何字符，包装类：java.lang.Character</li>
<li>boolean，默认值：false，包装类：java.lang.Boolean</li>
</ul>
<h2 id="面向对象的六大基本原册">面向对象的六大基本原册</h2>
<h3 id="单一职责原则single-responsibility-priciple">单一职责原则（Single Responsibility Priciple）</h3>
<ul>
<li>对于一个类而言，应该只有一个引起他变化的原因。</li>
<li>比如，不要将teacher,doctor都放在一个person类中，而是将其拆成teacher类，doctor类。</li>
<li>能够一定程度上降低耦合度。</li>
</ul>
<h3 id="开闭原则open-close-priciple">开闭原则（Open Close Priciple）</h3>
<ul>
<li>对于扩展是开放的，对于修改是关闭的。</li>
<li>一般来说就是不要修改之前的代码，可以选择继承或者实现接口来扩展对应的功能。</li>
</ul>
<h3 id="里式替换原则liskov-substitution-priciple">里式替换原则（Liskov Substitution Priciple）</h3>
<ul>
<li>所有引用父类的地方都可以透明的使用其子类对象。</li>
<li>即父类出现的地方，把父类换成子类不会出现异常或错误；反之，子类出现的地方，把子类换成父类可能会出现异常或错误。</li>
<li>比如,person类具有eat功能，那么将person.eat换成teacher.eat是没有问题的；而如果teacher类具有独特的teach功能，那么如果将teacher.teach换成person.teach就会出现错误。</li>
</ul>
<h3 id="依赖倒置原则dependence-inversion-priciple">依赖倒置原则（Dependence Inversion Priciple）</h3>
<ul>
<li>高层模块不依赖低层模块，而是应该依赖其抽象</li>
<li>抽象不依赖于细节，细节依赖于抽象</li>
<li>比如teacher类中应该尽量做一些老师共有的抽象行为，比如教书，这样后面的语文老师，数学老师等可以继承该抽象老师类进行扩展。</li>
</ul>
<h3 id="接口隔离原则interface-segregation-priciple">接口隔离原则（Interface Segregation Priciple）</h3>
<ul>
<li>客户端不应该依赖它不需要的接口;一个类对另一个类的依赖应该建立在最小的接口上</li>
<li>尽量一个接口只实现一个功能，如果接口功能太多可进行拆分。</li>
</ul>
<h3 id="迪米特原则law-of-demeter-or-least-knowlegde-priciple">迪米特原则（Law of Demeter or Least Knowlegde Priciple）</h3>
<ul>
<li>一个对象应该对其他对象有最少的了解。</li>
<li>此原则与接口隔离原则可以结合使用，尽量保持一个方法一个具体行为，而不要涵盖多个行为。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://philosopherzb.github.io/post/hello-gridea/</id>
        <link href="https://philosopherzb.github.io/post/hello-gridea/">
        </link>
        <updated>2020-09-03T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typora]]></title>
        <id>https://philosopherzb.github.io/post/typora/</id>
        <link href="https://philosopherzb.github.io/post/typora/">
        </link>
        <updated>2019-09-03T05:41:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="welcome">Welcome</h2>
<p>Thank you for choosing <strong>Typora</strong>. This document will help you to start Typora. Please note that Typora for Windows is still in beta phase, so this document may be updated in future version-ups.</p>
<h2 id="live-preview">Live Preview</h2>
<p><strong>Typora</strong> use the feature: <em>Live Preview</em>, meaning that you could see these inline styles after you finish typing, and see block styles when you type or after you press <code>Enter</code> key or focus to another paragraph. Just try to type some markdown in typora, and you would see how it works.</p>
<p><strong>Note</strong>: Markdown tags for inline styles, such as <code>**</code> will be hidden or displayed smartly. Markdown tags for block level styles, such as <code>###</code> or <code>- [x]</code> will be hidden once the block is rendered.</p>
<p>You could switch to source code mode temporary from menu bar, footer bar or short cut key (<code>ctrl+/</code>). But we only provide very basic support for source code mode and won't recommend users to do so.</p>
<h2 id="markdown-for-typora">Markdown For Typora</h2>
<p><strong>Typora</strong> is using <a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown</a> .</p>
<p>To see full markdown Syntax references and extra usage, please check <code>Help</code>-&gt;<code>Markdown Reference</code> in menu bar or <code>About</code> panel.</p>
<h2 id="shortcut-keys">Shortcut Keys</h2>
<p>You could find shortcut keys in the right side of menu items from menu bar.For more shortcut key details and custom key bindings, you can refer <a href="http://support.typora.io/Shortcut-Keys/">here</a>.</p>
<h2 id="copy">Copy</h2>
<p>We create typora and want to make it your default markdown editor, thus copy and paste means copy from another app or paste to another app, instead of <em>copy/paste from/to another markdown editor</em>. Therefore, by default, <code>Copy</code> means <code>Copy As HTML</code> ( and <code>Paste</code> means <code>Paste from HTML</code>).</p>
<p>However, after click &quot;<strong>Copy Markdown source by default</strong>&quot;, typora will copy selected text in HTML/markdown format (When pasting, rich editors will accept the HTML format, while plain text / code editor will accept the markdown source code format).</p>
<p>To <strong>copy Markdown source code</strong> explicitly, please use shortcut key <code>shift+cmd+c</code> or <code>Copy as Markdown</code> from menu. To <strong>Copy as HTML Code</strong>, please select <code>Copy as HTML Code</code> from menu.</p>
<h2 id="smart-paste">Smart Paste</h2>
<p><strong>Typora</strong> is able to analyze styles of the text content in your clipboard when pasting. For example, after pasting a <code>&lt;h1&gt;HEADING&lt;/h1&gt;</code> from some website, typora will keep the 'first level heading’ format instead of paste ‘heading’ as plain text.</p>
<p>To <strong>paste as markdown source</strong> or plain text, you should use <code>paste as plain text</code> or press the shortcut key: <code>shift+cmd+v</code>.</p>
<h2 id="themes">Themes</h2>
<p>Please refer to <code>Help</code> → <code>Custom Themes</code> from menu bar.</p>
<h2 id="publish">Publish</h2>
<p>Currently Typora only support to export as <strong>PDF</strong> or <strong>HTML</strong>. More data format support as import/export will be integrated in future.</p>
<h2 id="auto-save-and-file-recovery">Auto Save and File Recovery</h2>
<p>Typora support  auto save feature, user could enable it from preference panel.</p>
<p>Typora does not provide professional version control and file backup feature, but typora would backup the last file content from time to time automatically, so even when typora crashes or users forget to save the file before close, it is possible to recovery most of the work by clicking <code>Recovery Unsaved Drafts</code> from preference folder, and copy out backed-up files. The File name in this folder is consists of last saved date, originally file name and last saved timestamp.</p>
<h2 id="more-useful-tips-documents">More Useful Tips &amp; Documents</h2>
<p><a href="https://support.typora.io/">https://support.typora.io/</a></p>
<h2 id="and-more">And More ?</h2>
<p>For more questions or feedbacks, please contact us by:</p>
<ul>
<li>Home Page: http://typora.io</li>
<li>Email: <a href="mailto:hi@typora.io">hi@typora.io</a></li>
<li>Twitter <a href="https://twitter.com/typora">@typora</a></li>
</ul>
<p>We opened a Github issue page in case you want to start a discussion or as an alternative way to report bugs/suggestions: https://github.com/typora/typora-issues/issues</p>
]]></content>
    </entry>
</feed>