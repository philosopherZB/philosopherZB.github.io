<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://philosopherzb.github.io</id>
    <title>Philosopher</title>
    <updated>2023-03-01T09:02:27.132Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://philosopherzb.github.io"/>
    <link rel="self" href="https://philosopherzb.github.io/atom.xml"/>
    <subtitle>WORLD AS CODE</subtitle>
    <logo>https://philosopherzb.github.io/images/avatar.png</logo>
    <icon>https://philosopherzb.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Philosopher</rights>
    <entry>
        <title type="html"><![CDATA[java中引用&IO&类加载&对象创建过程]]></title>
        <id>https://philosopherzb.github.io/post/java-zhong-yin-yong-andioandlei-jia-zai-anddui-xiang-chuang-jian-guo-cheng/</id>
        <link href="https://philosopherzb.github.io/post/java-zhong-yin-yong-andioandlei-jia-zai-anddui-xiang-chuang-jian-guo-cheng/">
        </link>
        <updated>2021-03-06T08:10:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java中的四种引用类型，JavaIO类型（BIO，NIO，AIO），Java类加载机制以及Hotspot JVM虚拟机对象的探究。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/boat-1014711_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="四种引用">四种引用</h2>
<h3 id="强引用">强引用</h3>
<p>把一个对象复制给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，这时，GC不会对其进行回收（造成OOM的主要原因之一）。</p>
<pre><code>// 强引用
String str = &quot;test&quot;;
// 取消强引用
str = null;

</code></pre>
<h3 id="软引用">软引用</h3>
<p>软引用需要使用SoftReference类来实现，对于软引用对象来说，当系统内存足够时不会对其进行回收，反之则进行回收。通常应用在对内存敏感的程序中。</p>
<pre><code>// 软引用
SoftReference&lt;String&gt; softReference = new SoftReference&lt;&gt;(&quot;test&quot;);

</code></pre>
<h3 id="弱引用">弱引用</h3>
<p>弱引用需要使用WeakReference类来实现，它比软引用生存周期更短，对于弱引用对象来说，只要垃圾回收机制一运行，不管JVM内存空间是否充足，都会对其进行回收。</p>
<pre><code>// 弱引用
WeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(&quot;test&quot;);

</code></pre>
<h3 id="虚引用">虚引用</h3>
<p>虚引用需要使用PhantomReference类来实现，它不能单独使用，必须与引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。</p>
<pre><code>// 虚引用
ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;&gt;();
PhantomReference&lt;String&gt; pr = new PhantomReference&lt;&gt;(&quot;test&quot;, queue);

</code></pre>
<h2 id="java中的io">Java中的I/O</h2>
<h3 id="bioblock-io">BIO（Block IO）</h3>
<ul>
<li>同步阻塞式IO，一般指平常所用的IO类。</li>
<li>一个请求对应一个响应，为了合理的利用资源，可以使用多线程（线程池）。</li>
<li>此IO一般针对并发量较小的场景（&lt;1000）。</li>
<li>BIO操作的对象是流（Stream）。</li>
<li>比如：在ATM机上取钱，只能一个一个的取，前面有人的时候，需要等待；取钱的时候，需要本人进行相关取钱操作（取出之后拿到钱才走）。</li>
</ul>
<h3 id="nionew-io">NIO（New IO）</h3>
<ul>
<li>同步非阻塞式IO。</li>
<li>利用Channel（通道）通讯，实现了多路复用。</li>
<li>核心组件：Buffer（缓冲区），Channel（通道），Selector（选择器）</li>
<li>NIO操作的对象是缓存区（Buffer）。</li>
<li>基本运行流程：当Channel发生新连接、就绪读，就绪写的时候，首先会在Selector上注册相应的事件，生成一个与Channel绑定的selectKey；其次由一个线程轮询selectKey集合，利用操作系统底层的函数select() 或者 epoll（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是iocp）去操作系统查询IO是否就绪，如果就绪则执行相应的事件处理器（通过selectKey找到Channel，然后利用与Channel绑定的buffer进行实际读写）。</li>
<li>比如：在银行大厅取钱，对于前面是否有人等候，只需要隔一段时间去问一下大堂经理是否可以取钱就可以了，不需要一直去排队（这段时间可以做其他事）；取钱的时候，需要柜员进行相关操作，同时也需要保证你也在柜员面前（不能离开，不然柜员可能会找不到你，然后钱就没有实际拿到手里了）。</li>
</ul>
<h3 id="aioasynchronous-io">AIO（Asynchronous IO）</h3>
<ul>
<li>异步非阻塞式IO。</li>
<li>其实现是基于事件以及回调机制。</li>
<li>AIO与NIO有点相似，不过对于实际读写而言，AIO是交给操作系统底层自己去完成的，完成之后会返回一个IO完成的回调消息。</li>
<li>比如：同样是去银行取钱，不过这次你是让朋友去帮忙取的，你朋友会帮你排队，然后取钱，接着把钱给你，并告诉你已经取好了。</li>
</ul>
<h3 id="io阶段">IO阶段</h3>
<ul>
<li>IO中对于读写一般分为两个阶段：就绪读写（准备数据）以及实际读写（真正读写数据）。</li>
<li>对应上面取钱例子而言，就绪读写指的是排队，实际读写指的是取钱操作。</li>
</ul>
<h3 id="同步异步">同步，异步</h3>
<ul>
<li>同步指的是操作的时候，需要等待当前任务返回结果；异步则相反，它不需要等待当前任务返回，通常情况下是依赖于事件，回调机制来实现任务间的次序关系。</li>
<li>同步，异步对于IO而言指的是实际读写阶段；对应取钱例子而言，就是真正取钱操作（同步，自己取钱；异步，朋友帮忙取钱）。</li>
</ul>
<h3 id="阻塞非阻塞">阻塞，非阻塞</h3>
<ul>
<li>阻塞指的是如果任务在执行，当前线程会阻塞，需要等待任务执行完，这期间该线程不能执行其他任务；非阻塞则是说在一个任务执行期间，线程不会阻塞，可以执行其他任务。</li>
<li>阻塞，非阻塞对于IO而言指的是就绪读写阶段；对应取钱例子而言，就是排队等候（阻塞，排队没带手机，只能干等着；非阻塞，排队带了手机，可以一边玩手机一边排队）。</li>
</ul>
<h2 id="jvm类加载">JVM类加载</h2>
<h3 id="类加载机制">类加载机制</h3>
<p>JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301027.png" alt="img" loading="lazy"></figure>
<p>1、加载：在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口（注意：不一定非得从Class文件中获取，也可以从ZIP（如jar，war）中读取，或者在运行时计算生成（动态代理），或者由其他文件转换而来（如JSP转换为Class））。</p>
<p>2、验证：确保Class文件字节流中所包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>3、准备：正式为类变量分配内存并为其设置初始值，即在方法区中分配这些变量所使用的内存空间。需要注意这里所说的初始值概念，比如说一个类变量定义为：</p>
<pre><code>public static int port = 8080;
</code></pre>
<p>那么此变量在准备阶段所谓的设置初始值，是设置其为0，而不是8080。将port赋值为8080的put static 指令是程序被编译后，存放于类构造器<code>&lt;Client&gt;</code>方法中的。</p>
<p>但如果变量声明如下：</p>
<pre><code>public static final int port = 8080;
</code></pre>
<p>那么在编译期间，会为port生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将port赋值为8080.</p>
<p>4、解析：此阶段指虚拟机将常量池中的符号引用替换为直接引用的过程。</p>
<p>符号引用：与虚拟机实现的布局无关，引用的目标不一定要已经加载至内存中。各种虚拟机的内存布局可以不一致，但它们能接受的符号引用必须一致，因为符号引用的字面量形式明确的定义在java虚拟机规范的Class文件格式中。、</p>
<p>直接引用：是可以直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄，如果存在直接引用，那么引用的目标必定已经在内存中存在。</p>
<p>5、初始化：此阶段开始真正执行类中定义的java程序代码，即开始开始执行类构造器<code>&lt;client&gt;</code>方法。</p>
<p><code>&lt;client&gt;</code>方法是由编译器自动收集类中的类静态变量赋值以及静态语句块中的语句合并而成的。虚拟机会保证子<code>&lt;client&gt;</code>执行之前，父<code>&lt;client&gt;</code>已经执行完毕（如果一个类中既没有类静态变量赋值，也没有静态语句块，那虚拟机可以不为其生成<code>&lt;client&gt;</code>方法）。</p>
<p>注意以下几种情形不会执行类初始化：</p>
<ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化。</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在类的初始化。</li>
<li>通过类名获取Class对象，不会触发初始化。</li>
<li>通过Class.forName加载指定类时，如果指定参数initialize为false（initialize是告诉虚拟机是否要对该类进行初始化），也不会触发类的初始化。</li>
<li>通过ClassLoader默认的loadClass方法，不会触发类初始化。</li>
</ul>
<h3 id="类加载器">类加载器</h3>
<p>类的加载并没有发生在JVM中，而是由应用程序来确定如何获取所需要的类。为此JVM提供了三种类加载器，如下：</p>
<p>1、启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可的类（按文件名识别，如：rt.jar）。</p>
<p>2、扩展类加载器（Extension ClassLoader）：负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</p>
<p>3、应用程序类加载器（Application ClassLoader）：负责加载用户路径（classpath）上的类库。</p>
<h3 id="双亲委派模型">双亲委派模型</h3>
<p>JVM通过双亲委派模型进行类的加载，当然，开发者也可以通过集成java.lang.ClassLoader实现自定义的类加载器。</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301028.png" alt="" loading="lazy"></figure>
<p>双亲委派过程：当一个类收到类加载请求时，它首先不会尝试自己去加载这个类，而是将这个请求委派给父类去完成，每一层次的类加载器都是如此操作，因此所有的类加载请求都应该会传送到启动类加载器中，只有当父加载器无法加载此类时（在它的加载路径下没有找到所需加载的Class），子加载器才会尝试自己去加载。</p>
<p>双亲委派解决了java基础类统一加载的问题，但某些情况下父类加载器需要委托子类加载器去加载Class文件，例如SPI（Service Provider Interface）代码（spi是一种服务发现机制：即为某个接口寻找服务实现的机制。）。</p>
<h3 id="以jdbc为例谈双亲委派模型的破坏">以JDBC为例谈双亲委派模型的破坏</h3>
<p>Java本身有一套资源管理服务JNDI（Java Naming and Directory Interface，根据名称可以在其中查找对应的方法或者其他参数），其放置于rt.jar中，由启动类加载器进行加载。</p>
<p>以数据库管理JDBC为例，java给数据库操作提供了一个Driver（java.sql.Driver）接口，并提供了一个DriverManager（java.sql.DriverManager）来管理Driver的具体实现。</p>
<h4 id="不破坏双亲委派模型不使用jdni">不破坏双亲委派模型（不使用JDNI）</h4>
<pre><code>// 加载数据库驱动
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
// 连接到数据库上去
Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai&quot;,&quot;root&quot;,&quot;root&quot;);

</code></pre>
<p>Class.forName()触发了mysql驱动类的加载，通过源码可以发现，mysql的驱动类已经在静态块中被注册到了DriverManager中，所以后续使用时可以直接建立连接。其核心实现如下：</p>
<pre><code>public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    public Driver() throws SQLException {
    }

    static {
        try {
            DriverManager.registerDriver(new Driver());
        } catch (SQLException var1) {
            throw new RuntimeException(&quot;Can't register driver!&quot;);
        }
    }
}
</code></pre>
<pre><code>public static synchronized void registerDriver(java.sql.Driver driver,
        DriverAction da)
    throws SQLException {

    /* Register the driver if it has not already been added to our list */
    if(driver != null) {
        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));
    } else {
        // This is for compatibility with the original DriverManager
        throw new NullPointerException();
    }

    println(&quot;registerDriver: &quot; + driver);

}

</code></pre>
<h4 id="破坏双亲委派模型使用jdni">破坏双亲委派模型（使用JDNI）</h4>
<p>JDBC4.0以后，开始支持spi注册Driver，具体做法便是在mysql的jar中的META-INF/services/java.sql.Driver文件中指明当前的Driver，然后通过下列方式即可使用。</p>
<pre><code>// 连接到数据库上去
Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai&quot;,&quot;root&quot;,&quot;root&quot;);

</code></pre>
<p>此处相比于不破坏双亲委派模型，少了一句Class.forName()，即加载驱动类的步骤。其对应的Driver是配置在META-INF/services/java.sql.Drive文件中的，由此可以知道其操作为：先从配置文件中读取Driver，随后再进行加载（使用Class.forName()）</p>
<p>需要注意的是，Class.forName()加载的是调用者的ClassLoader，这个调用者DriverManager是在rt.jar中，ClassLoader是启动类加载器，而com.mysql.cj.jdbc.Driver并没有位于&lt;JAVA_HOME&gt;/lib下，所以肯定是无法直接加载到mysql的这个类的。这边是双亲委派的局限性，父类加载器无法加载子类加载器路径中的类（父对子透明，子对父不透明）。</p>
<p>为了让父类加载器加载子类加载器路径中的类，可以通过线程上下文加载器去加载第三方jar包中的Driver，这便打破了双亲委派模型。</p>
<p>以DriverManager为例，当调用其getConnection()方法时，会先执行器静态块中的初始化代码，如下：</p>
<pre><code>/**
 * Load the initial JDBC drivers by checking the System property
 * jdbc.properties and then use the {@code ServiceLoader} mechanism
 */
static {
    loadInitialDrivers();
    println(&quot;JDBC DriverManager initialized&quot;);
}

</code></pre>
<pre><code>AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
    public Void run() {
        // 各个sql厂商在自己的jar包中通过spi注册的驱动
        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);
        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();

        /* Load these drivers, so that they can be instantiated.
         * It may be the case that the driver class may not be there
         * i.e. there may be a packaged driver with the service class
         * as implementation of java.sql.Driver but the actual class
         * may be missing. In that case a java.util.ServiceConfigurationError
         * will be thrown at runtime by the VM trying to locate
         * and load the service.
         *
         * Adding a try catch block to catch those runtime errors
         * if driver not available in classpath but it's
         * packaged as service and that service is there in classpath.
         */
        try{
            while(driversIterator.hasNext()) {
                driversIterator.next();
            }
        } catch(Throwable t) {
        // Do nothing
        }
        return null;
    }
});

</code></pre>
<p>其中ServiceLoader.load()便是拿到线程上下文加载器，并构造了一个ServiceLoader进行返回，如下：</p>
<pre><code>public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}

public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,
                                        ClassLoader loader)
{
    return new ServiceLoader&lt;&gt;(service, loader);
}

</code></pre>
<p>DriverManager中的doPrivileged()中还有一句driversIterator.next()，其中实现了类加载过程，具体实现如下：</p>
<pre><code>private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null;
    Class&lt;?&gt; c = null;
    try {
        // 此处的cn便是便是厂商在META-INF/services/java.sql.Drive文件中配置的全限定驱动类名
        // loader则是上文中ServiceLoader.load()返回的线程上下文加载器。
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {
        fail(service,
             &quot;Provider &quot; + cn + &quot; not found&quot;);
    }
    if (!service.isAssignableFrom(c)) {
        fail(service,
             &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);
    }
    try {
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service,
             &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,
             x);
    }
    throw new Error();          // This cannot happen
}

</code></pre>
<h2 id="hotspot-jvm虚拟机对象探究">Hotspot JVM虚拟机对象探究</h2>
<h3 id="对象的创建以普通java对象new指令为例">对象的创建（以普通Java对象new指令为例）</h3>
<ul>
<li>当虚拟机遇到一条new指令时，首先会去常量池中检查是否存在这个对象的引用，并且检查该引用所代表的类是否已经被加载，解析和初始化过，如果没有，则先执行类加载。</li>
<li>当类加载检查通过之后，虚拟机将会为新生对象分配内存（对象所需的内存大小在类加载完成之后就已经确认了，为对象分配空间就是在Java堆上划分出一块内存来。一般有两种分配方式，根据内存规整程度分为：指针碰撞（规整）以及空闲列表（不规整））。</li>
<li>针对并发情况下对象内存分配冲突解决方案有：一是同步处理，二是使用本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）（虚拟机是否使用本地线程分配缓冲可通过-XX:+/-UseTLAB参数来设定）。</li>
<li>内存分配完毕之后，虚拟机会将对应的内存空间初始化为零值（不包括对象头）。接着会对这个对象进行必要的设置，例如此对象是哪个类的实例，如何查找类的元数据信息，对象的哈希码，对象的GC分代年龄等等，这些信息都放在了对象头中。</li>
<li>执行完new指令之后还需要执行<code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算是完全创建好了。</li>
</ul>
<h3 id="对象的内存布局">对象的内存布局</h3>
<ul>
<li>在HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header），实例数据（Instance Data）以及对齐填充（Padding）。</li>
<li>对象头（Header）主要包含两部分信息：第一部分用于存储对象自身的运行时数据（如哈希码（HashCode），GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据长度在32位或者64位的虚拟机中分别为32bit以及64bit，官方称之为“Mark Word”）；第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机可以通过这个指针来确定该对象属于哪个类的实例（并不是所有的虚拟机实现都需要在对象数据上保留类型指针，即查找对象的元数据信息并不一定要经过对象本身），如果对象是一个Java数组，那么对象头还需要记录该数组长度，因为普通的Java对象可以通过元数据信息确认对象大小，而数组却不行。</li>
<li>实例数据（Instance Data）存储着对象真正有效的信息，即各种类型的字段，无论是继承父类还是子类自定义。</li>
<li>对齐填充（Padding）不是必然存在的，也没有特殊的含义，仅仅起到占位符的作用，保证对象大小是某个字节的整数倍（HotSpot VM 的自动内存管理系统要求对象起始地址必须为8字节的整数倍）。</li>
</ul>
<h3 id="对象的访问定位">对象的访问定位</h3>
<ul>
<li>建立对象的目的是为了使用该对象，Java程序是通过栈上的reference指针来操作堆上的具体对象的。</li>
<li>目前主流的访问方式有句柄和直接指针两种。</li>
</ul>
<h4 id="句柄访问定位">句柄访问定位</h4>
<ul>
<li>使用句柄的话，Java堆将会划分出一块内存来作为句柄池，reference中存放的也就是对象的句柄地址（句柄中包含了对象实例数据和类型数据各自的地址）。</li>
<li>句柄的优势在于其稳定性更高，如果对象频繁的发生移动（GC操作时移动对象），那么只会改变句柄中的实例数据的指针，reference本身不需要改变。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301029.png" alt="img" loading="lazy"></figure>
<h4 id="直接访问定位">直接访问定位</h4>
<ul>
<li>使用直接指针，那么reference将直接指向对象对应的地址（Java堆布局时需要考虑如何存放访问类型数据的相关信息）。</li>
<li>直接指针的优势在于其速度更快，因为减少了一次指针定位的操作。如果对象访问频繁，那么使用直接访问将会提高相当不错的效率。</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301030.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM详解]]></title>
        <id>https://philosopherzb.github.io/post/jvm-xiang-jie/</id>
        <link href="https://philosopherzb.github.io/post/jvm-xiang-jie/">
        </link>
        <updated>2021-02-27T07:44:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述JVM，包括jvm线程，jvm运行时区域，jvm垃圾回收机制--回收算法以及垃圾回收器</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/mountains-139012_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="jvm概述">JVM概述</h2>
<h3 id="基本概念">基本概念</h3>
<p>JVM是运行java代码的虚拟计算机平台，它运行于计算机操作系统之上，并不直接与硬件进行交互。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301019.png" alt="img" loading="lazy"></figure>
<h3 id="运行过程">运行过程</h3>
<p><em>x.java源文件，通过编译器产生对应的</em>.Class字节码文件，之后又通过java虚拟机中的解释器，编译成特定机器上的机器码。</p>
<p>流程如下：</p>
<ul>
<li>Java源文件 ----&gt; 编译器 ----&gt; 字节码文件</li>
<li>字节码文件 ----&gt; JVM解释器 ----&gt; 机器码</li>
</ul>
<p>每一种平台的解释器都是不同的，但其依赖的虚拟机是一样的，这也就是java跨平台运行的核心原理。</p>
<p>虚拟机实例随着程序的运行而启动，程序退出或关闭则会使对应的虚拟机实例消亡。多个程序启动会存在多个虚拟机实例，各个虚拟机实例之间互不干扰，数据独立。</p>
<h2 id="jvm线程">JVM线程</h2>
<h3 id="线程">线程</h3>
<p>此处所说的线程为程序执行过程中的一个线程实体。JVM允许一个应用并发执行多个线程。</p>
<p>Hotspot JVM中的java线程与操作系统原生线程存在直接的映射关系：当java线程创建完毕后，会同步创建一个操作系统原生线程。java线程结束，原生线程也会随之被回收（原生线程由操作系统负责调度，如将其分配至可用的CPU）。</p>
<p>Hotspot JVM 后台运行的系统线程如下图所示：</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301020.png" alt="img" loading="lazy"></figure>
<h2 id="jvm内存区域">JVM内存区域</h2>
<h3 id="内存区域图">内存区域图</h3>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301021.png" alt="img" loading="lazy"></figure>
<h3 id="运行时数据区域">运行时数据区域</h3>
<p>Java虚拟机在执行java程序时，定义了若干程序运行期间会使用到的运行时数据区域，其中线程共享区域随着虚拟机的启动/关闭而创建/销毁，线程私有区域则与用户线程一一对应，会随着用户线程的启动/关闭而创建/销毁（ Hotspot JVM中，用户线程会与原生线程对应）。</p>
<p>运行时数据区域图如下：</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301022.png" alt="img" loading="lazy"></figure>
<h4 id="程序计数器program-counter-register">程序计数器（Program Counter Register）</h4>
<ul>
<li>是一块内存小，线程私有，且不会发生OOM（OutOfMemoryError）的区域（因为它只是当前线程所执行的字节码的行号指示器）。</li>
<li>在Java虚拟机概念模型中（仅仅指概念模型，各类不同的虚拟机可能有更高效的处理方式），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来完成。</li>
<li>Java虚拟机可以支持多线程同时执行（可参考《Java 语言规范》第 17 章），是通过轮转时间片的方式让处理器来执行线程的。在任意时刻，一个处理器（对于多核处理器来说是指一个内核）只会处理一个线程中的指令，为了保证线程切换能够回到正确的执行指令，Java虚拟机针对每个线程分配了一个独立的程序计数器，各线程之间的计数器互不干扰，独立存储。</li>
<li>如果线程正在执行的方法不是 native的（即Java方法），那程序计数器就保存 Java 虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那程序计数器的值是 undefined。</li>
<li>程序计数器的容量至少应当能保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值。</li>
</ul>
<h4 id="java虚拟机栈java-virtual-machine-stack">Java虚拟机栈（Java Virtual Machine Stack）</h4>
<ul>
<li>Java虚拟机栈是线程私有的，它的生命周期与线程一致。</li>
<li>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</li>
<li>局部变量表存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身)和 returnAddress 类型(指向了一条字节码指令的地址)。</li>
<li>需要注意的是64位的long以及double类型的数据会占用两个局部变量空间（Slot），其余的数据类型只占一个。局部变量表所需的内存空间在编译期间就已经完成了分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是已经确认了的，在方法运行期间不会去改变局部变量表的大小。</li>
<li>Java虚拟机栈有可能发生以下两种异常状况：如果线程请求分配的栈容量（栈深度）超过 Java 虚拟机栈允许的最大容量（深度）时，Java 虚拟机将会抛出一 个StackOverflowError异常；如果Java 虚拟机栈可以动态扩展（目前大部分虚拟机都支持动态扩展），并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 OutOfMemoryError异常。</li>
</ul>
<h4 id="本地方法栈native-method-stack">本地方法栈（Native Method Stack）</h4>
<ul>
<li>本地方法栈与Java虚拟机栈是非常类似的，他们的主要区别是Java虚拟机栈是服务于Java方法（字节码）的，而本地方法栈则是服务于Native方法的。</li>
<li>与Java虚拟机栈一样，本地方法栈同样会出现StackOverflowError异常和OutOfMemoryError异常。</li>
</ul>
<h4 id="java堆java-heap">Java堆（Java Heap）</h4>
<ul>
<li>在 Java 虚拟机中，堆（Heap）是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域，一般而言堆（Heap）占用的内存空间也是最大的。</li>
<li>Java 堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统（Automatic Storage Management System，也即是常说的“Garbage Collector（垃圾收集器）”）所管理的各种对象，这些受管理的对象无需，也无法显式地被销毁。所以一般我们也称Java堆为GC堆（Garbage Collected Heap）。</li>
<li>如果实际所需的堆超过了自动内存管理系统能提供的最大容量（或者说堆中没有内存来完成实例分配，且无法扩展），那 Java 虚拟机将会抛出一个 OutOfMemoryError异常。</li>
</ul>
<h4 id="方法区method-area">方法区（Method Area）</h4>
<ul>
<li>在 Java 虚拟机中，方法区（Method Area）是可供各条线程共享的运行时内存区域。</li>
<li>它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法（即存储着已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据）。</li>
<li>如果方法区的内存空间不能满足内存分配请求，那 Java 虚拟机将抛出一个 OutOfMemoryError异常。</li>
</ul>
<h4 id="运行时常量池runtime-constant-pool">运行时常量池（Runtime Constant Pool）</h4>
<ul>
<li>运行时常量池是方法区（Method Area）的一部分。</li>
<li>它是每一个类或接口的常量池（Constant_Pool）的运行时表示形式，它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。</li>
<li>一般情况下，除了保存Class文件中描述的符号引用外，还会把翻译过来的直接引用也保存在运行时常量池中。</li>
<li>运行时常量池相对于Class文件常量池的另一个特征是具备动态性，即运行期间也可将新的常量放入池中，比如String.intern()方法。</li>
<li>当创建类或接口的时候，如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li>
</ul>
<h4 id="直接内存direct-memory">直接内存（Direct Memory）</h4>
<ul>
<li>直接内存并不属于Java虚拟机运行时内存区域，也不是Java虚拟机规范中定义的内存区域。</li>
<li>在这里提出来的主要原因是因为Java在1.4版本引入了NIO类，是一种基于通道（Channel）和缓存区（Buffer）的IO操作，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</li>
<li>在某些情况下，通过减少Java堆和Native堆来回复制数据的操作，从而提高一些性能。</li>
<li>因为这块内存也是实际存在的，所以受硬件总内存影响，如果需要对虚拟机内存进行扩容操作，需要考虑虚拟机内存加直接内存超过物理内存限制所引起的 OutOfMemoryError异常。</li>
</ul>
<h3 id="jvm运行时内存">JVM运行时内存</h3>
<h4 id="分代">分代</h4>
<p>Java堆从GC角度还可以细分为新生代（Eden区，From Survivor区，To Survivor区），老年代。</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301023.png" alt="img" loading="lazy"></figure>
<h4 id="新生代">新生代</h4>
<p>用于存储初创对象，一般占据堆内存1/3。对象的创建频繁且杂多，所以此区域会经常触发MinorGC进行垃圾回收。</p>
<h5 id="新生代细分区域">新生代细分区域</h5>
<p>Eden区：Java新对象的出生地（如果新创建的对象占用内存过大，将直接被分配至老年代），当Eden内存不足时，将触发一次MinorGC，对其进行垃圾回收。</p>
<p>From Survivor区：上一次GC的幸存者存放在此区域，将作为这一次GC的扫描对象。</p>
<p>To Survivor区：经历一次MinorGC过程的幸存者。</p>
<h5 id="新生代gc过程复制算法">新生代GC过程（复制算法）</h5>
<p>首先将Eden和From Survivor区域中存活的对象复制到To Survivor区域（From Survivor区如果存在对象年龄且大于阈值，则直接复制到老年代），同时将这些对象的年龄+1（如果To Survivor区被填满了，剩余的对象会被复制到老年代中）。随后清空Eden和From Survivor区域中的死对象。最后，将From Survivor和To Survivor调换名字，这样，在下一次GC时，原To Survivor将成为From Survivor。</p>
<h4 id="老年代">老年代</h4>
<p>主要存储应用程序中生命周期较长的内存对象。进入老年代的对象一般都比较稳定，所以不会频繁地执行MajorGC。</p>
<p>MajorGC采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收未标记的对象。此过程耗时较长，且会产生内存碎片。</p>
<h4 id="永久代">永久代</h4>
<p>内存的永久保存区域，主要存放Class以及Meta（元数据）信息。Class在被加载时便放入永久区域，它跟存放实例的区域不同，GC不会在主程序执行期间对永久区域进行清理。所以，这也导致了永久区域随着加载的Class增多而不断膨胀，最终抛出OOM异常。</p>
<p>Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所替代。元空间的本质与永久代类似，它们之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p>
<h3 id="垃圾回收与算法">垃圾回收与算法</h3>
<h4 id="gc算法图">GC算法图</h4>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301024.png" alt="img" loading="lazy"></figure>
<h4 id="垃圾确认算法">垃圾确认算法</h4>
<p>引用计数法：对象被引用则+1，否则-1，为0时将被回收（存在循环引用问题）。</p>
<p>可达性分析：为了避免引用计数法中的循环引用问题，如今java一般采用可达性分析，通过一系列的GC ROOTS（VM栈中的引用，方法区中的静态引用，JNI中的引用等）作为对象的起点搜索。如果GC ROOTS和一个对象之间没有可达路径，则称其为不可达。需要注意的是：不可达对象不等价于可回收对象，不可达对象变为可回收对象最少需要经历两次标记过程，如果仍然不可达，则会面临回收。</p>
<h4 id="垃圾收集算法">垃圾收集算法</h4>
<h5 id="标记清除算法mark-sweep">标记清除算法（Mark-Sweep）</h5>
<p>最基础的垃圾回收算法，分为两个阶段，标记和清除。如下图所示（容易出现内存碎片）：</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301025.png" alt="img" loading="lazy"></figure>
<h5 id="复制算法copying">复制算法（copying）</h5>
<p>为了解决Mark-Sweep算法中内存碎片化的缺陷而被提出的算法。</p>
<p>它按内存容量将内存划分为等大小的两块，每次只使用其中一块，当这一块内存满了之后，便将其中存活的对象移至另一块内存上去，同时把已使用的内存清理掉。</p>
<p>这种算法实现简单，内存效率高，不易产生碎片，但同时也带来了一个问题，那就是可用内存被压缩到了原来的一半，且当存活对象过多时，其算法效率又会大大降低。</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301026.png" alt="img" loading="lazy"></figure>
<h5 id="分代收集算法">分代收集算法</h5>
<p>此算法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域。</p>
<p>一般情况下，会将GC堆划分为老年代（Tenured/Old Generation）和新生代（Young Generation）。</p>
<p>老年代的特点是每次需要回收的对象很少，新生代则与之相反，因此可以根据不同的区域选择不同的算法。</p>
<p>新生代由于需要经常进行垃圾回收，所以可以采用复制算法（一般会将其再次划分为Eden，From Survivor以及To Survivor三个区域，比例为8:1:1（实际调优需要根据具体的业务调整））。</p>
<p>老年代则一般采用标记复制算法或者标记整理算法，可根据具体场景指定。</p>
<h3 id="gc垃圾收集器">GC垃圾收集器</h3>
<h4 id="serial垃圾收集器单线程复制算法">Serial垃圾收集器（单线程，复制算法）</h4>
<p>Serial是最基本的垃圾收集器，使用复制算法。JDK1.3.1之前，它是新生代唯一的垃圾收集器。</p>
<p>Serial是一个单线程的收集器，它不但只会用一个CPU或一条线程去完成垃圾收集工作，并且在进行垃圾收集的过程中，还要暂停其他所有线程（stop the world），直到垃圾收集结束。</p>
<p>Serial在执行时虽然会暂停其他所有线程，但其简单高效，对于限定单个CPU的环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率。</p>
<p>因此，Serial依旧是java虚拟机运行在Client模式下新生代的默认垃圾收集器。</p>
<h4 id="parnew垃圾收集器serial-多线程">ParNew垃圾收集器（serial + 多线程）</h4>
<p>ParNew其实是Serial收集器的多线程版本，除了多线程之外，其余与Serial完全一致。</p>
<p>ParNew默认开启和CPU数目相同的线程数，可以通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数。</p>
<p>相较于Seria而言，ParNew是java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p>
<h4 id="parallel-scavenge垃圾收集器多线程复制算法高效">Parallel Scavenge垃圾收集器（多线程复制算法，高效）</h4>
<p>Parallel Scavenge 是一个新生代垃圾收集器，使用复制算法，且为多线程。其重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU用于运行用户代码时间/CPU总消耗时间，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））。</p>
<p>高吞吐量可以最高效率的利用CPU时间，尽快地完成程序的运行任务，主要适用于在后台运算，而不需要太多交互的任务。</p>
<p>自适应调节策略也是Parallel Scavenge与ParNew的一个重要区别。</p>
<h4 id="serial-old垃圾收集器单线程标记整理算法">Serial Old垃圾收集器（单线程，标记整理算法）</h4>
<p>Serial Old是Serial垃圾收集器的老年代版本，它同样是单线程的，使用的算法为标记整理。Serial Old是java虚拟机运行在Client模式下老年代的默认垃圾收集器。</p>
<p>其在Server模式下，主要有两个用途：</p>
<p>1、在JDK1.5之前版本与新生代的Parallel Scavenge收集器搭配使用。</p>
<p>2、作为老年代中CMS的后备垃圾收集器。</p>
<h4 id="parallel-old垃圾收集器多线程标记整理算法">Parallel Old垃圾收集器（多线程，标记整理算法）</h4>
<p>Parallel Old是Parallel Scavenge垃圾收集器的老年代版本，它同样是多线程的，使用的算法为标记整理（JDK1.6之后才提供）。</p>
<h4 id="cms垃圾收集器多线程标记清除算法">CMS垃圾收集器（多线程，标记清除算法）</h4>
<p>Concurrent Mark Sweep是一种老年代垃圾收集器，其主要目的是为了获取最短垃圾回收停顿时间（在交互过程中提高用户体验），使用的算法为标记清除。</p>
<p>CMS执行过程：</p>
<ol>
<li>初始标记：标记一下GC ROOTS能直接关联的对象，速度很快，需要暂停工作线程。</li>
<li>并发标记：进行GC ROOTS跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</li>
<li>重新标记：为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记录，需要暂停工作线程。</li>
<li>并发清除：清除GC ROOTS不可达对象，和用户线程一起工作，不需要暂停工作线程，由于耗时最长的并发标记和并发清除是与用户线程一起工作的，所以总体上来看，CMS收集过程与用户线程是并发执行的。</li>
</ol>
<h4 id="g1垃圾收集器多线程标记整理算法">G1垃圾收集器（多线程，标记整理算法）</h4>
<p>Garbage first是目前垃圾收集器理论发展的最前沿成果，相比于CMS收集器，G1最突出的两个改进为：</p>
<ol>
<li>基于标记整理算法，不会产生内存碎片。</li>
<li>可以非常精准的控制停顿时间，在不牺牲吞吐量的前提下，实现低停顿回收。</li>
</ol>
<p>G1避免全区域的垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。</p>
<p>区域划分和优先级区域回收机制，确保了G1可以在有限的时间内获得最高的垃圾收集效率。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java8新特性Stream&CompletableFuture]]></title>
        <id>https://philosopherzb.github.io/post/java8-xin-te-xing-streamandcompletablefuture/</id>
        <link href="https://philosopherzb.github.io/post/java8-xin-te-xing-streamandcompletablefuture/">
        </link>
        <updated>2021-02-17T07:16:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java8新特性，主要是Stream和CompletableFuture的常用例子</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/mountain-477832_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="stream">Stream</h2>
<pre><code>// 获取某个属性的和
System.out.println(personPojos.stream().mapToInt(PersonPojo::getCount).sum());
// 最大值
System.out.println(personPojos.stream().mapToInt(PersonPojo::getCount).max());
// 最小值
System.out.println(personPojos.stream().mapToInt(PersonPojo::getCount).min());
// 平均值
System.out.println(personPojos.stream().mapToInt(PersonPojo::getCount).average());

// 获取某个属性值最大的集合
Optional&lt;PersonPojo&gt; couponConfigOptional = personPojos.stream().
        filter(Objects::nonNull).
        filter(personPojo -&gt; StringUtils.isNotEmpty(personPojo.getEndTime())).
        max(Comparator.comparing(PersonPojo::getEndTime));
couponConfigOptional.ifPresent(personPojo -&gt; System.out.println(JSONObject.toJSONString(personPojo)));


// 以对象的某个属性分组
Map&lt;String, List&lt;PersonPojo&gt;&gt; resultMap = personPojos.stream().collect(Collectors.groupingBy(PersonPojo::getName));
System.out.println(JSONObject.toJSONString(resultMap));

// 以对象某个属性分组，同时只取列表中的第一条数据
Map&lt;String, PersonPojo&gt; resultMap = personPojos.stream().collect(Collectors.groupingBy(PersonPojo::getName,Collectors.collectingAndThen(Collectors.toList(), value-&gt;value.get(0)))))));
System.out.println(JSONObject.toJSONString(resultMap));

// 以对象的某个属性分组，并只汇总某一个属性字段
Map&lt;String, List&lt;String&gt;&gt; map = personPojos.stream().collect(Collectors.groupingBy(PersonPojo::getId, Collectors.mapping(PersonPojo::getName, Collectors.toList())));
System.out.println(JSONObject.toJSONString(map));

// 过滤不包含某个对象
List&lt;PersonPojo&gt; filters = personPojos.stream().filter(personPojo-&gt;!personPojos.contains(personPojo)).collect(Collectors.toList());
System.out.println(JSONObject.toJSONString(filters));

// 移除不在有效期内的数据
long currentTime = System.currentTimeMillis();
personPojos.removeIf(personPojo -&gt; currentTime &lt; personPojo.getStartTime().getTime() || currentTime &gt; personPojo.getEndTime().getTime());

// 获取某个字段作为新的list
List&lt;String&gt; names =personPojos.stream().map(PersonPojo::getName).collect(Collectors.toList());
System.out.println(JSONObject.toJSONString(names));

// 获取某个字段作为新的list，去重
List&lt;String&gt; distinctNames =personPojos.stream().map(PersonPojo::getName).distinct().collect(Collectors.toList());
System.out.println(JSONObject.toJSONString(distinctNames));

// 判断对象组中是否存在包含指定值的对象
boolean match = personPojos.stream().anyMatch(personPojo -&gt; &quot;zhangsan&quot;.equals(personPojo.getName()));
System.out.println(match);
// 判断对象组是否都是包含指定值的对象
boolean match2 = personPojos.stream().allMatch(personPojo -&gt; &quot;zhangsan&quot;.equals(personPojo.getName()));
System.out.println(match2);

//返回 对象集合以类属性一升序排序
list.stream().sorted(Comparator.comparing(类::属性一));

//返回 对象集合以类属性一降序排序 注意两种写法
list.stream().sorted(Comparator.comparing(类::属性一).reversed());//先以属性一升序,结果进行属性一降序
list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));//以属性一降序

//返回 对象集合以类属性一升序 属性二升序
list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));

//返回 对象集合以类属性一降序 属性二升序 注意两种写法
//先以属性一升序,升序结果进行属性一降序,再进行属性二升序
list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));
//先以属性一降序,再进行属性二升序
list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));

//返回 对象集合以类属性一降序 属性二降序 注意两种写法
//先以属性一升序,升序结果进行属性一降序,再进行属性二降序
list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二,Comparator.reverseOrder()));
//先以属性一降序,再进行属性二降序
list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二,Comparator.reverseOrder()));

//返回 对象集合以类属性一升序 属性二降序 注意两种写法
//先以属性一升序,升序结果进行属性一降序,再进行属性二升序,结果进行属性一降序属性二降序
list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二).reversed());
//先以属性一升序,再进行属性二降序
list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二,Comparator.reverseOrder()));

// 多属性分组
Map&lt;String, Map&lt;String, List&lt;PersonPojo&gt;&gt;&gt; mapMap = personPojos.stream()
        .collect(Collectors.groupingBy(PersonPojo::getId, Collectors.groupingBy(PersonPojo::getName)));
System.out.println(JSONObject.toJSONString(mapMap));

// 多个属性合成一个属性
Map&lt;String, List&lt;PersonPojo&gt;&gt; map = personPojos.stream().collect(Collectors.groupingBy(Test5::fetchGroupKey));
System.out.println(JSONObject.toJSONString(map));
private static String fetchGroupKey(PersonPojo p) {
    return p.getId() + &quot;_&quot; + p.getName();
}

</code></pre>
<h2 id="completablefuture">CompletableFuture</h2>
<pre><code>package com.philosopherzb.demo.test;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * @author philosopherZB
 * @date 2021/9/28
 */
public class Test10 {
    public static void main(String[] args) {
//        Test10.testThenAccept();
//        Test10.testThenRun();
//        Test10.testThenApply();
//        Test10.testThenCombine();
//        Test10.testThenCompose();
//        Test10.testApplyToEither();
//        Test10.testExceptionally();
//        Test10.testHandle();
        Test10.testAllOf();
//        Test10.testGet();
    }

    /**
     * 功能: 当前任务正常完成后执行，且当前任务的返回值可作为下个任务的入参；thenAccept本身并没有返回值
     * 样例: 接受第一个任务执行结果的字符串，并将其与第二个任务的字符串进行拼接操作
     */
    private static void testThenAccept() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;first&quot;);
        first.thenAccept(f -&gt; {
            System.out.println(&quot;accept firstFuture result: &quot; + f);
            System.out.println(&quot;Splicing result: &quot; + f + &quot;second&quot;);
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 当前任务正常完成后执行；thenRun本身并没有返回值
     * 样例: 异步顺序执行
     */
    private static void testThenRun() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(&quot;first&quot;);
            return &quot;first&quot;;
        });
        first.thenRun(() -&gt; System.out.println(&quot;result: &quot; + &quot;second&quot;)).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 当前任务正常完成后执行，且当前任务的返回值可作为下个任务的入参；thenApply本身有返回值
     * 样例: 接受第一个任务执行结果的字符串，并将其与第二个任务的字符串进行拼接操作，最后将结果与第三个任务的字符串拼接（多个任务串行）
     */
    private static void testThenApply() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;first&quot;);
        CompletableFuture&lt;String&gt; second = first.thenApply(f -&gt; {
            System.out.println(&quot;second accept firstFuture result: &quot; + f);
            System.out.println(&quot;second Splicing result: &quot; + f + &quot;second&quot;);
            return f + &quot;second&quot;;
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
        second.thenApply(s -&gt; {
            System.out.println(&quot;second.thenApply accept firstFuture result: &quot; + s);
            System.out.println(&quot;second.thenApply Splicing result: &quot; + s + &quot;third&quot;);
            return s + &quot;third&quot;;
        }).whenComplete((r, throwable) -&gt; {
            System.out.println(&quot;third result: &quot; + r);
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 处理两个CompletionStage的结果并进行返回；thenCombine 本身有返回值
     * 样例: 拼接字符串
     */
    private static void testThenCombine() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;first&quot;);
        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; &quot;second&quot;);
        // 有返回值
        first.thenCombine(second, (f, s) -&gt; f + s).whenComplete((r, throwable) -&gt; {
            System.out.println(&quot;thenCombine result: &quot; + r);
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
        // 无返回值
        first.thenAcceptBoth(second, (f, s) -&gt; {
            System.out.println(&quot;thenAcceptBoth result: &quot; + f + s);
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
        // 无返回值, 在两个任务执行后执行
        first.runAfterBoth(second, () -&gt; {
            System.out.println(&quot;runAfterBoth result: &quot;);
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 处理两个CompletionStage的结果并进行返回, 与thenApply类似，不过lambda接受的是一个CompletableFuture；thenCompose 本身有返回值
     * 样例: 拼接字符串
     */
    private static void testThenCompose() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;first&quot;);
        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; &quot;second&quot;);
        // 有返回值
        first.thenCompose(f -&gt; second.thenApply(s -&gt; f + s)).whenComplete((r, throwable) -&gt; {
            System.out.println(&quot;thenCompose result: &quot; + r);
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 运行两个CompletionStage，并将最先处理结束的结果返回；applyToEither 本身有返回值
     * 样例: 返回最快处理结果
     */
    private static void testApplyToEither() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;first-sleep-1000&quot;;
        });
        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;second-sleep-2000&quot;;
        });
        // 获取一下返回值，否则以下代码不会执行
        System.out.println(&quot;=====&gt;&quot; + second.join());
        // 有返回值
        CompletableFuture&lt;String&gt; third = first.applyToEither(second, s -&gt; s).whenComplete((r, throwable) -&gt; {
            System.out.println(&quot;applyToEither result: &quot; + r);
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
        // 无返回值
        first.acceptEither(second, s -&gt; {
            System.out.println(&quot;acceptEither result: &quot; + s);
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
        // 无返回值, 在两个任务执行后执行
        first.runAfterEither(second, () -&gt; {
            System.out.println(&quot;runAfterEither result: &quot;);
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 处理运行时异常，并进行额外的补偿操作（类似于try catch）；exceptionally 本身有返回值
     * 样例: 处理异常
     */
    private static void testExceptionally() {
        // 发生异常，thenApply不会执行（thenApply必须在程序正常运行后才会执行）
        CompletableFuture.supplyAsync(() -&gt; &quot;result: &quot; + (3 / 0))
                .thenApply(s -&gt; {
                    System.out.println(&quot;first not running: &quot; + s);
                    return s;
                })
                .exceptionally(throwable -&gt; {
                    System.out.println(&quot;first e: &quot; + throwable.getLocalizedMessage());
                    return &quot;first occur exception&quot;;
                })
                .whenComplete((r, throwable) -&gt; {
                    System.out.println(&quot;first exceptionally result: &quot; + r);
                    if (throwable != null) {
                        System.out.println(throwable.getLocalizedMessage());
                    }
                });
        // 正常运行，thenApply执行
        CompletableFuture.supplyAsync(() -&gt; &quot;result: &quot; + (3 / 1))
                .thenApply(s -&gt; {
                    System.out.println(&quot;second running: &quot; + s);
                    return s;
                })
                .exceptionally(throwable -&gt; {
                    System.out.println(&quot;second e: &quot; + throwable.getLocalizedMessage());
                    return &quot;second occur exception&quot;;
                })
                .whenComplete((r, throwable) -&gt; {
                    System.out.println(&quot;second exceptionally result: &quot; + r);
                    if (throwable != null) {
                        System.out.println(throwable.getLocalizedMessage());
                    }
                });
    }

    /**
     * 功能: handle类似于whenComplete，区别在于：handle 有返回值， whenComplete 无返回值
     * 样例: 打印返回值
     */
    private static void testHandle() {
        // 发生异常，thenApply不会执行（thenApply必须在程序正常运行后才会执行）
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;result: &quot; + (3 / 0))
                .thenApply(s -&gt; {
                    System.out.println(&quot;first not running: &quot; + s);
                    return s;
                })
                .exceptionally(throwable -&gt; {
                    System.out.println(&quot;first e: &quot; + throwable.getLocalizedMessage());
                    return &quot;first occur exception&quot;;
                })
                .handle((r, throwable) -&gt; {
                    System.out.println(&quot;first handle result: &quot; + r);
                    if (throwable != null) {
                        System.out.println(throwable.getLocalizedMessage());
                    }
                    return r;
                });
        // 正常运行，thenApply执行
        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; &quot;result: &quot; + (3 / 1))
                .thenApply(s -&gt; {
                    System.out.println(&quot;second running: &quot; + s);
                    return s;
                })
                .exceptionally(throwable -&gt; {
                    System.out.println(&quot;second e: &quot; + throwable.getLocalizedMessage());
                    return &quot;second occur exception&quot;;
                })
                .handle((r, throwable) -&gt; {
                    System.out.println(&quot;second handle result: &quot; + r);
                    if (throwable != null) {
                        System.out.println(throwable.getLocalizedMessage());
                    }
                    return r;
                });

        System.out.println(&quot;join result: &quot; + first.join());
        System.out.println(&quot;join result: &quot; + second.join());
    }

    /**
     * 功能: 所有任务完成后执行:allOf; 任意任务完成后执行：anyOf
     * 样例: 异步查询三个任务信息并返回
     */
    private static void testAllOf() {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        long start = System.currentTimeMillis();

        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(1000 + ThreadLocalRandom.current().nextInt(1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;first&quot;;
        }, executorService);
        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(1000 + ThreadLocalRandom.current().nextInt(1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;second&quot;;
        }, executorService);
        CompletableFuture&lt;String&gt; third = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(1000 + ThreadLocalRandom.current().nextInt(1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;third&quot;;
        }, executorService);
        // 所有任务完成后执行
        CompletableFuture.allOf(first, second, third).join();
        System.out.println(first.join() + second.join() + third.join());
        System.out.println(System.currentTimeMillis() - start);

        // 任意任务完成后执行
        CompletableFuture.anyOf(first, second, third).join();
        System.out.println(first.join() + second.join() + third.join());
        System.out.println(System.currentTimeMillis() - start);
    }

    /**
     * 获取返回值
     */
    private static void testGet() {
        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &quot;content&quot;).whenComplete(((result, throwable) -&gt; {
            System.out.println(&quot;result: &quot; + result);
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        }));
        try {
            System.out.println(&quot;cf get: &quot; + cf.get());
            System.out.println(&quot;cf getWithTimeOut: &quot; + cf.get(1, TimeUnit.SECONDS));
            System.out.println(&quot;cf join: &quot; + cf.join());
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            e.printStackTrace();
        }

    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ArrayList源码解析(JDK8)]]></title>
        <id>https://philosopherzb.github.io/post/arraylist-yuan-ma-jie-xi-jdk8/</id>
        <link href="https://philosopherzb.github.io/post/arraylist-yuan-ma-jie-xi-jdk8/">
        </link>
        <updated>2021-02-06T06:58:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java中的ArrayList的源码以及其中如何进行扩容的逻辑分析（jdk8）</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/road-1072821_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="源码来自于jdk8">源码来自于JDK8</h2>
<pre><code>package java.util;

import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import sun.misc.SharedSecrets;

//其中实现了RandomAccess接口表示支持随机访问
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{
    //序列号
    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * 默认初始容量
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * 共享的空数组实例（用于空实例）
     * 当ArrayList(int initialCapacity)，ArrayList(Collection&lt;? extends E&gt; c)中的容量等于0的时候使用
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

    /**
     * 共享的空数组实例（用于默认大小的空实例）
     * 将其与EMPTY_ELEMENTDATA区分开来，主要是为了知道第一次添加元素的时候需要扩容多少
     * 用于ArrayList()构造器
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     * ArrayList保存有序元素的数组
     * ArraylList容量为数组容量
     * 任何空数组都使用 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * 当第一次添加元素的时候其容量将会扩容至 DEFAULT_CAPACITY（10）
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * ArrayList的大小（包含元素的数量）
     * @serial
     */
    private int size;

    /**
     * 带指定容量参数的构造器，如果元素数量较大的话，可以使用此构造器，防止频繁扩容造成的性能损失
     */
    public ArrayList(int initialCapacity) {
        //如果传入值大于0，则创建一个该容量大小的数组。
        if (initialCapacity &gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            //否则如果传入值等于0，则创建默认空数组
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            //如果小于0则抛出异常
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                    initialCapacity);
        }
    }

    /**
     * 默认构造函数，其初始容量为10（注意，这里一开始其实是一个空数组，只是当add时才会进行扩容至10的操作，一定程度上减小了内存消耗。）
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    /**
     * 构造一个包含指定集合元素的列表，元素顺序由集合的迭代器所返回。
     */
    public ArrayList(Collection&lt;? extends E&gt; c) {
        //集合转数组
        elementData = c.toArray();
        //指定集合含有元素
        if ((size = elementData.length) != 0) {
            // c.toArray可能不会返回Object[] (see 6260652)
            //使用反射进行运行时判断elementData是否属于Object[]
            if (elementData.getClass() != Object[].class)
                //拷贝数组
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // 由空数组代替
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }

    /**
     * 修改ArrayList容量为list的当前大小
     * 一个应用可以使用此操作来最小化一个ArrayList的存储
     */
    public void trimToSize() {
        modCount++;
        //如果当前数组元素个数小于数组容量
        if (size &lt; elementData.length) {
            //没有元素返回空数组，否则返回元素个数的数组。
            elementData = (size == 0)
                    ? EMPTY_ELEMENTDATA
                    : Arrays.copyOf(elementData, size);
        }
    }

    /**
     * 如果有必要去增加ArrayList的容量，请确保它至少可以容纳由最小容量参数指定的元素数量
     * @param   minCapacity   所需的最小容量
     */
    public void ensureCapacity(int minCapacity) {
        //默认最小容量，空数组以及默认大小10
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                // any size if not default element table
                ? 0
                // larger than default for default empty table. It's already
                // supposed to be at default size.
                : DEFAULT_CAPACITY;

        //如果传入容量大于最小容量，则进行扩容
        if (minCapacity &gt; minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
    }

    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        //如果elementData为默认空数组，则比较传入值与默认值（10），返回两者中的较大值
        //elementData为默认空数组指的是通过ArrayList()这个构造器创建的ArrayList对象
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        //返回传入值
        return minCapacity;
    }

    private void ensureCapacityInternal(int minCapacity) {
        //先通过calculateCapacity方法计算最终容量，以确认实际容量
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        //如果最终确认容量大于数组容量，则进行grow()扩容
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    }

    /**
     * 可分配数组最大大小
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * 增加ArrayList的容量，以确保它至少可以容纳由最小容量参数指定的元素数量
     * @param minCapacity 所需的最小容量
     */
    private void grow(int minCapacity) {
        // overflow-conscious code
        //oldCapacity表示旧容量
        int oldCapacity = elementData.length;
        //newCapacity表示新容量，计算规则为旧容量+旧容量的0.5，即旧容量的1.5倍。如果超过int的最大值会返回一个负数。
        //oldCapacity &gt;&gt; 1表示右移一位，对应除以2的1次方。
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        //如果新容量小于最小容量，则将最小容量赋值给新容量(有时手动扩容可能也会返回&lt;0，对应方法为ensureCapacity())
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        //如果新容量大于MAX_ARRAY_SIZE，则执行hugeCapacity(minCapacity)返回对应值
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        //复制旧数组到新容量数组中，完成扩容操作
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        //如果最小容量超过了int的最大值，minCapacity会是一个负数，此时抛出内存溢出错误
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        //比较最小容量是否大于MAX_ARRAY_SIZE，如果是则返回Integer.MAX_VALUE，否则返回MAX_ARRAY_SIZE
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
                Integer.MAX_VALUE :
                MAX_ARRAY_SIZE;
    }

    /**
     * 返回列表元素数
     */
    public int size() {
        return size;
    }

    /**
     * 如果列表不包含元素，返回true
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 如果列表包含指定元素，返回true
     */
    public boolean contains(Object o) {
        //返回此列表中指定元素第一次出现的索引，如果列表中不包含指定元素，则为-1
        return indexOf(o) &gt;= 0;
    }

    /**
     * 返回此列表中指定元素第一次出现的索引，如果列表中不包含指定元素，则为-1
     */
    public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i &lt; size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i &lt; size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * 返回此列表中指定元素最后一次出现的索引，如果列表中不包含指定元素，则为-1
     */
    public int lastIndexOf(Object o) {
        if (o == null) {
            for (int i = size-1; i &gt;= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = size-1; i &gt;= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * 返回ArrayList实例的一个浅拷贝，列表中的元素不会被拷贝
     */
    public Object clone() {
        try {
            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn't happen, since we are Cloneable
            throw new InternalError(e);
        }
    }

    /**
     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。
     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。
     * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。
     */
    public Object[] toArray() {
        return Arrays.copyOf(elementData, size);
    }

    /**
     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;
     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。
     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。
     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。
     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T[] toArray(T[] a) {
        if (a.length &lt; size)
            //创建一个新的运行时类型数组，内容为ArrayList数组的
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length &gt; size)
            a[size] = null;
        return a;
    }

    // 位置访问操作

    @SuppressWarnings(&quot;unchecked&quot;)
    E elementData(int index) {
        return (E) elementData[index];
    }

    /**
     * 返回此列表中指定位置的元素
     */
    public E get(int index) {
        //检查索引是否越界
        rangeCheck(index);

        return elementData(index);
    }

    /**
     * 用指定元素替换列表中的指定位置的元素
     */
    public E set(int index, E element) {
        //检查索引是否越界
        rangeCheck(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        return oldValue;
    }

    /**
     * 将指定元素追加到数组末尾
     */
    public boolean add(E e) {
        //添加之前先确认是否需要扩容
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //新加入的元素是添加在了数组的末尾，随后数组size自增。
        elementData[size++] = e;
        return true;
    }

    /**
     * 插入指定元素到此列表中的指定位置
     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //自己复制自己
        System.arraycopy(elementData, index, elementData, index + 1,
                size - index);
        elementData[index] = element;
        size++;
    }

    /**
     * 将列表中指定位置的元素移除，后续所有元素移到左端（从他们的索引中减去一个）
     */
    public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                    numMoved);
        elementData[--size] = null; //  清理工作交给GC

        return oldValue;
    }

    /**
     * 从列表中移除第一次出现的指定元素，如果不存在，则不更改
     */
    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index &lt; size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index &lt; size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

    /*
     * Private remove method that skips bounds checking and does not
     * return the value removed.
     */
    private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                    numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }

    /**
     * 移除列表中的所有元素，之后会返回一个空数组
     */
    public void clear() {
        modCount++;

        // clear to let GC do its work
        for (int i = 0; i &lt; size; i++)
            elementData[i] = null;

        size = 0;
    }

    /**
     * 将指定集合中的元素以Iterator返回的顺序，追加到列表末尾
     */
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }

    /**
     * 将指定集合中的元素以Iterator返回的顺序，插入到指定位置
     */
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                    numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }

    /**
     * 移除[fromIndex,toIndex)之间的元素，后续元素移到左端
     */
    protected void removeRange(int fromIndex, int toIndex) {
        modCount++;
        int numMoved = size - toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                numMoved);

        // clear to let GC do its work
        int newSize = size - (toIndex-fromIndex);
        for (int i = newSize; i &lt; size; i++) {
            elementData[i] = null;
        }
        size = newSize;
    }

    /**
     *检查给定索引是否在界限内。
     */
    private void rangeCheck(int index) {
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * add and addAll使用的rangeCheck
     */
    private void rangeCheckForAdd(int index) {
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * 返回 an IndexOutOfBoundsException 的细节信息
     */
    private String outOfBoundsMsg(int index) {
        return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;
    }

    /**
     * 从列表中移除指定集合包含的所有元素
     */
    public boolean removeAll(Collection&lt;?&gt; c) {
        Objects.requireNonNull(c);
        return batchRemove(c, false);
    }

    /**
     * 保留此列表中指定集合的所有元素
     */
    public boolean retainAll(Collection&lt;?&gt; c) {
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    }

    //批量移除
    private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
        final Object[] elementData = this.elementData;
        int r = 0, w = 0;
        boolean modified = false;
        try {
            for (; r &lt; size; r++)
                if (c.contains(elementData[r]) == complement)
                    elementData[w++] = elementData[r];
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            if (r != size) {
                System.arraycopy(elementData, r,
                        elementData, w,
                        size - r);
                w += size - r;
            }
            if (w != size) {
                // clear to let GC do its work
                for (int i = w; i &lt; size; i++)
                    elementData[i] = null;
                modCount += size - w;
                size = w;
                modified = true;
            }
        }
        return modified;
    }

    /**
     * 保存ArrayList状态到一个流中（即序列化）
     */
    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException{
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioural compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }

    /**
     * 从一个流中读取ArrayList（即反序列化）
     */
    private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        elementData = EMPTY_ELEMENTDATA;

        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in capacity
        s.readInt(); // ignored

        if (size &gt; 0) {
            // be like clone(), allocate array based upon size not capacity
            int capacity = calculateCapacity(elementData, size);
            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
            ensureCapacityInternal(size);

            Object[] a = elementData;
            // Read in all elements in the proper order.
            for (int i=0; i&lt;size; i++) {
                a[i] = s.readObject();
            }
        }
    }

    /**
     *  从列表中的指定位置开始，返回之后所有元素的列表迭代器（按正确的顺序）
     *  指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。
     *  返回的列表迭代器是fail-fast 。
     */
    public ListIterator&lt;E&gt; listIterator(int index) {
        if (index &lt; 0 || index &gt; size)
            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);
        return new ListItr(index);
    }

    /**
     * 返回列表中的包含所有元素的列表迭代器（按正确的顺序）。
     * 返回的列表迭代器是fail-fast 。
     */
    public ListIterator&lt;E&gt; listIterator() {
        return new ListItr(0);
    }

    /**
     * 以正确的顺序返回列表中的包含所有元素的迭代器。
     * 返回的迭代器是fail-fast 。
     */
    public Iterator&lt;E&gt; iterator() {
        return new Itr();
    }

    @Override
    public void forEach(Consumer&lt;? super E&gt; action) {
        Objects.requireNonNull(action);
        final int expectedModCount = modCount;
        @SuppressWarnings(&quot;unchecked&quot;)
        final E[] elementData = (E[]) this.elementData;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
            action.accept(elementData[i]);
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }


    @Override
    public boolean removeIf(Predicate&lt;? super E&gt; filter) {
        Objects.requireNonNull(filter);
        // figure out which elements are to be removed
        // any exception thrown from the filter predicate at this stage
        // will leave the collection unmodified
        int removeCount = 0;
        final BitSet removeSet = new BitSet(size);
        final int expectedModCount = modCount;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
            @SuppressWarnings(&quot;unchecked&quot;)
            final E element = (E) elementData[i];
            if (filter.test(element)) {
                removeSet.set(i);
                removeCount++;
            }
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }

        // shift surviving elements left over the spaces left by removed elements
        final boolean anyToRemove = removeCount &gt; 0;
        if (anyToRemove) {
            final int newSize = size - removeCount;
            for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) {
                i = removeSet.nextClearBit(i);
                elementData[j] = elementData[i];
            }
            for (int k=newSize; k &lt; size; k++) {
                elementData[k] = null;  // Let gc do its work
            }
            this.size = newSize;
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
            modCount++;
        }

        return anyToRemove;
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void replaceAll(UnaryOperator&lt;E&gt; operator) {
        Objects.requireNonNull(operator);
        final int expectedModCount = modCount;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
            elementData[i] = operator.apply((E) elementData[i]);
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void sort(Comparator&lt;? super E&gt; c) {
        final int expectedModCount = modCount;
        Arrays.sort((E[]) elementData, 0, size, c);
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }
}

</code></pre>
<h2 id="扩容源码解析jdk8">扩容源码解析（JDK8）</h2>
<p>首先我们使用 ArrayList <code>&lt;String&gt;</code> list = new ArrayList&lt;&gt;(5)创建一个ArrayLsit，这表明创建的ArrayList初始容量为5.</p>
<pre><code>    //默认初始容量10
    private static final int DEFAULT_CAPACITY = 10;
    //一个空的默认对象数组，当ArrayList(int initialCapacity)，ArrayList(Collection&lt;? extends E&gt; c)中的容量等于0的时候使用
    private static final Object[] EMPTY_ELEMENTDATA = {};
    //一个空的默认对象数组，用于ArrayList()构造器
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    //一个对象数组，transient表示不能序列化
    transient Object[] elementData;
    //数组大小
    private int size;

    //以传入的容量构造一个空的list
    public ArrayList(int initialCapacity) {
        //如果传入值大于0，则创建一个该容量大小的数组。
        if (initialCapacity &gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            //否则如果传入值等于0，则创建默认空数组
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            //如果小于0则抛出异常
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                    initialCapacity);
        }
    }

</code></pre>
<p>接着我们使用add方法添加一个字符串到该list中，list.add(&quot;Test&quot;)。进入add源码会发现，真正的扩容是发生在add操作之前的。</p>
<pre><code>    //默认添加在数组末尾
    public boolean add(E e) {
        //添加之前先确认是否需要扩容
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //新加入的元素是添加在了数组的末尾，随后数组size自增。
        elementData[size++] = e;
        return true;
    }

</code></pre>
<p>进入ensureCapacityInternal()方法查看对应源码如下：</p>
<pre><code>    private void ensureCapacityInternal(int minCapacity) {
        //先通过calculateCapacity方法计算最终容量，以确认实际容量
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

</code></pre>
<p>到这一步，我们需要先进入calculateCapacity()方法看看他是如何计算最后容量的，源码如下：</p>
<pre><code>    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        //如果elementData为默认空数组，则比较传入值与默认值（10），返回两者中的较大值
        //elementData为默认空数组指的是通过ArrayList()这个构造器创建的ArrayList对象
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        //返回传入值
        return minCapacity;
    }

</code></pre>
<p>现在我们确认了最终容量，那么进入ensureExplicitCapacity，查看源码如下：</p>
<pre><code>    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;
        // overflow-conscious code
        //如果最终确认容量大于数组容量，则进行grow()扩容
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    }

</code></pre>
<p>可以看到，只有当最终容量大于数组容量时才会进行扩容。那么以我们上面的例子而言具体分析如下：</p>
<ol>
<li>首先因为我们创建的时候就赋了初始容量5，所以elementData.length = 5。</li>
<li>当我们add第一个元素的时候，minCapacity是等于size + 1 = 1的。</li>
<li>此时minCapacity - elementData.length &gt; 0条件不成立，所以不会进入grow(minCapacity)方法进行扩容。</li>
<li>以此类推，只有添加到第五个元素的时候，minCapacity = 6 大于 elementData.length = 5，这时就会进入grow(minCapacity)方法进行扩容。</li>
</ol>
<p>grow()以及hugeCapacity()源码如下：</p>
<pre><code>    //可分配的最大数组大小
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    //扩容
    private void grow(int minCapacity) {
        // overflow-conscious code
        //oldCapacity表示旧容量
        int oldCapacity = elementData.length;
        //newCapacity表示新容量，计算规则为旧容量+旧容量的0.5，即旧容量的1.5倍。如果超过int的最大值会返回一个负数。
        //oldCapacity &gt;&gt; 1表示右移一位，对应除以2的1次方。
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        //如果新容量小于最小容量，则将最小容量赋值给新容量(有时手动扩容可能也会返回&lt;0，对应方法为ensureCapacity())
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        //如果新容量大于MAX_ARRAY_SIZE，则执行hugeCapacity(minCapacity)返回对应值
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        //复制旧数组到新容量数组中，完成扩容操作
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        //如果最小容量超过了int的最大值，minCapacity会是一个负数，此时抛出内存溢出错误
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        //比较最小容量是否大于MAX_ARRAY_SIZE，如果是则返回Integer.MAX_VALUE，否则返回MAX_ARRAY_SIZE
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
                Integer.MAX_VALUE :
                MAX_ARRAY_SIZE;
    }

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的锁]]></title>
        <id>https://philosopherzb.github.io/post/java-zhong-de-suo/</id>
        <link href="https://philosopherzb.github.io/post/java-zhong-de-suo/">
        </link>
        <updated>2021-01-16T03:27:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java中的锁，包括锁类型，锁升级，锁优化等细节内容。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/railroad-g16c0f522b_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="锁的类型">锁的类型</h2>
<h3 id="乐观锁">乐观锁</h3>
<p>乐观锁认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是，在更新的时候会判断一下在此期间别人有没有去修改这个数据，采取写时先读出当前版本号，然后加锁操作（比较上一次的版本号，一致则更新），如果失败则重复读-比较-写操作。</p>
<p>CAS便是典型的乐观锁机制，其中会使用到sun.misc.Unsafe这个类进行Compare And Swap操作。</p>
<p>CAS 即比较并交换。是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS 操作包含三个操作数——内存位置(V)、预期原值(A)和新值(B)。如果内存位置的值(V)与预期原值(A)相匹配，那么处理器会自动将该位置值更新为新值(B)。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置(V)应该包含值(A)。如果包含该值，则将新值(B)放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可”。</p>
<h3 id="悲观锁">悲观锁</h3>
<p>悲观锁认为写操作更多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以会在每次读写的时候上锁，这样别人想读写这个数据便会block直到获取锁。</p>
<p>Synchronized便是典型的悲观锁，AQS框架下的锁会先尝试CAS获取锁，获取不到便会转为悲观锁。</p>
<h2 id="线程切换及其代价">线程切换及其代价</h2>
<h3 id="线程切换">线程切换</h3>
<p>java线程与操作系统上的原生线程是一一映射的。如果需要阻塞或者唤醒一个线程，便需要操作系统的介入，并切换用户态与内核态（这样的切换需要消耗大量的系统资源）。</p>
<h4 id="用户态切换到内核态的步骤主要如下">用户态切换到内核态的步骤主要如下</h4>
<ol>
<li>从当前进程的描述符中提取其内核栈的ss0及esp0信息。</li>
<li>使用ss0和esp0指向的内核栈将当前进程的cs，eip，eflags，ss，esp信息保存起来，这个过程也完成了由用户态到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</li>
<li>将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</li>
</ol>
<h4 id="名词解释如下">名词解释如下</h4>
<p>CS：代码段寄存器；存放当前正在运行的程序代码所在段的段基值；联合ip作为cpu指向当前正在执行的指令，不能随便修改。</p>
<p>DS：数据段寄存器；存放数据段的段基值；定义了一个数据段。</p>
<p>SS：堆栈段寄存器；存放堆栈段的段基值，联合sp定义一个堆栈值，一旦确定了堆栈地址，将不能随便改变。</p>
<p>内核态切换到用户态主要使用PSW（Program Status Word，程序状态字，又称状态寄存器），其一般用于反映处理器的状态及某些计算结果以及控制指令的执行：</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301001.png" alt="" loading="lazy"></figure>
<h3 id="切换的代价">切换的代价</h3>
<ul>
<li>如果线程切换是一个高频操作，那将耗费很多CPU处理时间（用户态，内核态之间的切换）。</li>
<li>甚至，如果同步代码块中的内容过于简单，状态切换消耗的时间有可能比用户代码执行的时间还要长。</li>
</ul>
<h2 id="java对象结构之对象头">Java对象结构之对象头</h2>
<h3 id="对象头">对象头</h3>
<p>对象头（Header）主要包含两部分信息：第一部分用于存储对象自身的运行时数据（如哈希码（HashCode），GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据长度在32位或者64位的虚拟机中分别为32bit以及64bit，官方称之为“Mark Word”）；</p>
<p>第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机可以通过这个指针来确定该对象属于哪个类的实例（并不是所有的虚拟机实现都需要在对象数据上保留类型指针，即查找对象的元数据信息并不一定要经过对象本身）。</p>
<p>如果对象是一个Java数组，那么对象头还需要记录该数组长度，因为普通的Java对象可以通过元数据信息确认对象大小，而数组却不行。</p>
<h3 id="markword">MarkWord</h3>
<p>markword数据的长度在32位和64位（未开启压缩指针）的虚拟机中分别为32bit和64bit，它的最后两位便是锁状态标识位，用来标记当前对象的状态，常用值如下：</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301002.png" alt="" loading="lazy"></figure>
<p>32位虚拟机在不同状态下markword的结构图如下：</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301003.png" alt="img" loading="lazy"></figure>
<h2 id="java中的锁">Java中的锁</h2>
<h3 id="主流锁图">主流锁图</h3>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301004.png" alt="img" loading="lazy"></figure>
<h3 id="自旋锁基于cas">自旋锁（基于CAS）</h3>
<p>如果持有锁的线程可以在很短的时间内释放锁，那么那些等待锁的线程便不需要进入阻塞挂起状态，而是自旋等待一会儿便可获取到同步资源，从而避免了线程切换的开销，这就是自旋锁。</p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。</p>
<p>自旋锁虽然避免了线程切换的开销，但其占据了CPU处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好；反之，则会白白浪费处理器资源。甚至，当线程过多时，还会影响系统的整体性能。</p>
<p>因此，自旋等待的时间需要有一个限度，如果超过限定次数（默认10次，可以使用-XX:PreBlockSpin来更改）没有获取到锁，则应当挂起线程。</p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301005.png" alt="img" loading="lazy"></figure>
<h4 id="jvm针对当前cpu的负荷情况还做了如下自旋锁优化操作">JVM针对当前CPU的负荷情况还做了如下自旋锁优化操作：</h4>
<ul>
<li>如果平均负载小于CPUs则一直自旋</li>
<li>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞</li>
<li>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞</li>
<li>如果CPU处于节电模式则停止自旋</li>
<li>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）</li>
<li>自旋时会适当放弃线程优先级之间的差异</li>
</ul>
<h3 id="synchronized无锁偏向锁轻量级锁重量级锁">Synchronized（无锁，偏向锁，轻量级锁，重量级锁）</h3>
<h4 id="synchronized队列">Synchronized队列</h4>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301006.png" alt="img" loading="lazy"></figure>
<p>可以看出，synchronized有多个队列，当多个线程一起访问某个对象监视器（monitor，其是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步））的时候，对象监视器会将这些线程存储在不同的容器里。</p>
<h5 id="结构概述">结构概述</h5>
<ul>
<li>ContentionList：竞争队列，所有请求锁的线程首先会被放入此队列中。</li>
<li>EntryList：ContentionList中一些有资格获取同步资源的线程将被移动到此队列中。</li>
<li>WaitSet：调用wait方法被阻塞的线程，放于此处。</li>
<li>OnDeck：任何时刻，最多只有一个线程正在竞争锁，该线程便是OnDeck。</li>
<li>Owner：已经获取到锁的线程被称为Owner。</li>
<li>!Owner：已经释放锁的线程。</li>
</ul>
<h5 id="队列协作过程">队列协作过程</h5>
<ul>
<li>JVM每次都会从队列尾部取出一个线程用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList会被大量的线程进行CAS访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList中作为候选竞争线程。</li>
<li>Owner在unlock时，也会将ContentionList中的部分线程迁移到EntryList，并指定EntryList中的某个线程为Ondeck（一般是最先进去的线程）。</li>
<li>Owner不会直接将锁传递给OnDeck，而是将锁竞争的权利交给OnDeck，OnDeck需要重新去竞争锁。这样虽然牺牲了一些公平性，但能极大的提高系统吞吐量，在JVM中，这种选择行为被称为“竞争切换”。</li>
<li>OnDeck获取到锁后就会变为Owner，而没有得到锁的则仍然停留在EntryList；如果OnDeck线程被wait阻塞，则会被移动至WaitSet，直到某个时刻被notify或notifyAll唤醒，才能重新进入EntryLIst。</li>
<li>处于ContentionList、EntryList、WaitSet中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux内核下采用pthread_mutex_lock内核函数实现的）。</li>
</ul>
<h4 id="无锁cas">无锁（CAS）</h4>
<p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<h4 id="偏向锁">偏向锁</h4>
<p>偏向锁是指一段同步代码一直被一个线程所访问，那么这个线程便会自动获取锁，降低了获取锁的代价。</p>
<p>在运行过程中，不存在多线程竞争，则线程不需要触发同步，此时为了提高线程执行同步代码的效率，便出现了偏向锁。</p>
<h5 id="偏向锁执行过程">偏向锁执行过程</h5>
<ol>
<li>访问MarkWord中偏向锁的标识位是否设置为1，锁标识位是否设置为01，确认为可偏向状态。</li>
<li>如果为可偏向状态，则判断线程id是否指向当前线程，如果是，则进入步骤5，否则进入步骤3。</li>
<li>如果线程id未指向当前线程，则通过CAS操作竞争锁，如果竞争成功，则将MarkWord中的线程id设置为当前线程id，然后执行步骤5，否则进入步骤4。</li>
<li>如果CAS获取锁失败，则表示存在锁竞争。当到达全局安全点（safepoint，会导致很短时间的stop-the-world）时，获取偏向锁的线程将被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li>
<li>执行同步代码。</li>
</ol>
<h5 id="偏向锁的释放">偏向锁的释放</h5>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。</p>
<p>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<h5 id="偏向锁适用场景">偏向锁适用场景</h5>
<p>始终只有一个线程操作同步资源，也就是锁无竞争状况下使用。一旦有了竞争，偏向锁便会升级为轻量级锁（升级需要撤销偏向锁，这个过程会stop-the-world）。</p>
<p>如果存在高并发锁竞争，应当禁用偏向锁，这样可以适当提高程序性能。</p>
<h5 id="jvm开启关闭偏向锁">jvm开启/关闭偏向锁</h5>
<p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0<br>
（-XX:BiasedLockingStartupDelay=0的作用是在虚拟机启动后，立即启用偏向锁，如果不设置该参数，默认虚拟会在4秒后，才启动偏向锁。）</p>
<p>关闭偏向锁：-XX:-UseBiasedLocking</p>
<h4 id="轻量级锁">轻量级锁</h4>
<p>轻量级锁是由偏向锁升级而来的，当一个线程持有偏向锁执行同步块时，存在另外的线程来竞争锁，这时偏向锁便会升级为轻量级锁。</p>
<p>轻量级锁执行过程：</p>
<p>a、在代码进入同步块的时候，如果同步对象状态为无锁状态（锁标识位：01，是否偏向锁标识位：0），虚拟机首先会在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的MarkWord的拷贝（官方称之为Displaced Mark Word）。线程堆栈与对象头状态图如下：</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301007.png" alt="img" loading="lazy"></figure>
<p>b、拷贝对象头的MarkWord复制到锁记录中。</p>
<p>c、拷贝成功后，虚拟机将使用CAS操作尝试将对象的MarkWord更新为指向Lock Record的指针，并将Lock Record中的owner指针指向object mark word，如果更新成功，则执行步骤d，否则执行步骤e。</p>
<p>d、更新成功后，该线程便拥有了这个对象的锁，此时对象MarkWord中的锁标识位将被设置为‘00’，表示此对象处于轻量级锁定状态。线程堆栈与对象头状态图如下：</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301008.png" alt="img" loading="lazy"></figure>
<p>e、如果这个更新操作失败了，虚拟机首先会检查对象的MarkWord是否指向当前线程的栈帧，如果是，则表示当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明有多个线程在竞争锁。</p>
<p>若当前只有一个等待线程，则该线程进行自旋等待，当自旋超过阈值，或者一个线程持有锁，一个在自旋，又有第三个来访问锁时，轻量级锁便会膨胀为重量级锁。</p>
<p>锁的标识位将被设置为‘10’，MarkWord中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也会进入阻塞状态。</p>
<h4 id="整体执行过程">整体执行过程</h4>
<h5 id="锁升级流程图">锁升级流程图：</h5>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301009.png" alt="img" loading="lazy"></figure>
<h5 id="synchronized执行过程">synchronized执行过程：</h5>
<ol>
<li>检测Mark Word中的锁标识是否为可偏向状态（锁标识位：01，是否偏向锁：1），如果是，则为偏向锁。</li>
<li>如果不是，则检查Mark Word里面的线程id是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li>
<li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li>
<li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li>
<li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li>
<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>
<li>如果自旋成功则依然处于轻量级状态。</li>
<li>如果自旋失败，则升级为重量级锁。</li>
</ol>
<h3 id="锁优化">锁优化</h3>
<h4 id="减少锁的时间">减少锁的时间</h4>
<p>不需要同步执行的代码，尽量不要放在同步块中，这样可以让锁更快的释放。</p>
<h4 id="减少锁的粒度">减少锁的粒度</h4>
<p>锁粒度的减少核心思想是利用空间换时间，它将物理上的一个锁，拆分为逻辑上的多个锁，增加并发度，从而降低了锁竞争。</p>
<p>典型代表有：ConcurrentHashMap（jdk1.8之前，有用到Segment数组）；LongAdder（实现机制与ConcurrentHashMap类似，其中有一个根据当前并发状态动态改变的Cell数组，注意：其竞争维度为cell个数+1，因为还有一个base数组）；LinkedBlockQueue（出队，入队采用了不同的锁，增加了并行效率）。</p>
<p>锁的拆分不能无限拆，需要根据当前系统CPU核数进行限制（不能超过CPU核数）。</p>
<h4 id="锁粗化">锁粗化</h4>
<p>大部分情况下，是要求将锁粒度减小，但某些情况下，也需要粗化锁粒度，比如循环中加锁。</p>
<h4 id="使用读写锁">使用读写锁</h4>
<p>ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写。例如：CopyOnWriteArrayList 、CopyOnWriteArraySet</p>
<p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>CopyOnWrite并发容器用于读多写少的并发场景，因为，读的时候没有锁，但是对其进行更改的时候是会加锁的，否则会导致多个线程同时复制出多个副本，各自修改各自的。</p>
<h4 id="使用cas">使用CAS</h4>
<p>如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用cas效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+cas操作会是非常高效的选择。</p>
<h4 id="消除缓存行的伪共享">消除缓存行的伪共享</h4>
<p>除了我们在代码中使用的同步锁和jvm自己内置的同步锁外，还有一种隐藏的锁就是缓存行，它也被称为性能杀手。</p>
<p>在多核cup的处理器中，每个cup都有自己独占的一级缓存、二级缓存，甚至还有一个共享的三级缓存，为了提高性能，cpu读写数据是以缓存行为最小单元读写的；32位的cpu缓存行为32字节，64位cup的缓存行为64字节，这就导致了一些问题。</p>
<p>例如，多个不需要同步的变量因为存储在连续的32字节或64字节里面，当需要其中的一个变量时，就将它们作为一个缓存行一起加载到某个cup-1私有的缓存中（虽然只需要一个变量，但是cpu读取会以缓存行为最小单位，将其相邻的变量一起读入），被读入cpu缓存的变量相当于是对主内存变量的一个拷贝，也相当于变相的将在同一个缓存行中的几个变量加了一把锁，这个缓存行中任何一个变量发生了变化，当cup-2需要读取这个缓存行时，就需要先将cup-1中被改变了的整个缓存行更新回主存（即使其它变量没有更改），然后cup-2才能够读取，而cup-2可能需要更改这个缓存行的变量与cpu-1已经更改的缓存行中的变量是不一样的，所以这相当于给几个毫不相关的变量加了一把同步锁；</p>
<p>为了防止伪共享，不同jdk版本实现方式是不一样的：</p>
<ol>
<li>在jdk1.7之前会 将需要独占缓存行的变量前后添加一组long类型的变量，依靠这些无意义的数组的填充做到一个变量自己独占一个缓存行；</li>
<li>在jdk1.7因为jvm会将这些没有用到的变量优化掉，所以采用继承一个声明了好多long变量的类的方式来实现；</li>
<li>在jdk1.8中通过添加sun.misc.Contended注解来解决这个问题，若要使该注解有效必须在jvm中添加以下参数：-XX:-RestrictContended。sun.misc.Contended注解会在变量前面添加128字节的padding将当前变量与其他变量进行隔离</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java线程池详解]]></title>
        <id>https://philosopherzb.github.io/post/java-xian-cheng-chi-xiang-jie/</id>
        <link href="https://philosopherzb.github.io/post/java-xian-cheng-chi-xiang-jie/">
        </link>
        <updated>2021-01-09T05:49:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java中关于线程池的优势，参数说明以及常用线程数配置。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/beach-gc2b0bd8e5_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="线程池">线程池</h2>
<h3 id="线程池的优势">线程池的优势</h3>
<ul>
<li>降低系统资源消耗：通过重用已存在的线程，降低线程创建和销毁所造成的资源消耗。</li>
<li>提供系统响应速度：当任务来临时，直接复用已存在的线程进行工作，而无需等待线程的创建。</li>
<li>方便线程数的管控：过多的线程创建，会导致性能的急剧下降（线程上下文切换十分耗费性能），甚至出现OOM。</li>
<li>提供更加强大的功能，如延时定时线程池。</li>
</ul>
<h3 id="线程池的主要参数">线程池的主要参数</h3>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
</code></pre>
<ul>
<li>corePoolSize：核心线程数，默认情况下，核心线程一直存活在线程池中，即使它们处于闲置状态（可通过allowCoreThreadTimeOut进行控制）。当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会创建一个新的线程来执行任务，直到创建的线程数大于或等于corePoolSize时才进行线程复用（可通过prestartCoreThread()或者prestartAllCoreThreads()来提前启动线程池中的基本线程）。</li>
<li>maximumPoolSize：最大线程数，当队列满了，且已创建线程数小于maximumPoolSize时，线程池会创建新的线程来执行任务。</li>
<li>keepAliveTime：线程闲置时长，超过此时长将会被销毁。默认只对非核心线程生效，只有当ThreadPoolExecutor中的allowCoreThreadTimeOut设置为true时，才会对核心线程生效。</li>
<li>unit：用于指定keepAliveTime参数的时间单位。</li>
<li>workQueue：工作队列，用于保存等待执行的任务的阻塞队列。通过线程池的execute方法提交的Runnable对象都会存储在该队列中。</li>
</ul>
<ol>
<li>ArrayBlockingQueue：基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</li>
<li>LinkedBlockingQueue：基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</li>
<li>SynchronousQueue：内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于SynchronousQueue中的数据元素只有当我们试着取走的时候才可能存在。</li>
<li>PriorityBlockingQueue：具有优先级的无限阻塞队列。</li>
<li>通过实现BlockingQueue接口来自定义所需要的阻塞队列</li>
</ol>
<ul>
<li>threadFactory：线程工厂，用于创建新线程。</li>
<li>handler：拒绝策略，当线程池饱和时（任务队列以及活动线程数都已达到最大值），此时便会执行对应的拒绝策略。</li>
</ul>
<ol>
<li>CallerRunsPolicy：使用调用者所在线程来运行任务。</li>
<li>AbortPolicy：直接抛出RejectedExecutionException异常。</li>
<li>DiscardPolicy：丢弃掉该任务，不进行处理</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
</ol>
<h3 id="线程池流程图">线程池流程图</h3>
<ol>
<li>如果在线程池中的线程数量没有达到核心线程数量，这时候就会启动一个核心线程来执行任务（等于核心线程数时，会复用线程池中已存在的线程）。</li>
<li>如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。</li>
<li>由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值（maximumPoolSize），那么这时候就会立即启动一个非核心线程来执行任务。</li>
<li>如果线程池中的数量达到了所规定的最大值（maximumPoolSize），那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230228001.png" alt="img" loading="lazy"></figure>
<h3 id="四种线程池一般不推荐使用">四种线程池（一般不推荐使用）</h3>
<p>1、newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换），无界线程池，容易发生OOM。</p>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}

</code></pre>
<p>2、newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）</p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}

</code></pre>
<p>3、newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。</p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}

</code></pre>
<p>4、newScheduledThreadPool：适用于执行延时或者周期性任务.</p>
<pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
//实例：
ScheduledExecutorService service = Executors.newScheduledThreadPool(4);
service.schedule(() -&gt; System.out.println(Thread.currentThread().getName()+&quot;延迟三秒执行&quot;), 3, TimeUnit.SECONDS);
service.scheduleAtFixedRate(() -&gt; System.out.println(Thread.currentThread().getName()+&quot;延迟三秒后每隔2秒执行&quot;), 3, 2, TimeUnit.SECONDS);

</code></pre>
<p>schedule(Runnable command, long delay, TimeUnit unit)：延迟一定时间后执行Runnable任务；</p>
<p>schedule(Callable callable, long delay, TimeUnit unit)：延迟一定时间后执行Callable任务；</p>
<p>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)：延迟一定时间后，以间隔period时间的频率周期性地执行任务(固定频率的含义就是可能设定的固定时间不足以完成线程任务，但是它不管，达到设定的延迟时间了就要执行下一次了)；</p>
<p>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit)：与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔，也就是这一些任务系列的触发时间都是可预知的.</p>
<h3 id="线程池中的线程数配置">线程池中的线程数配置</h3>
<ul>
<li>CPU密集型任务：线程池中线程个数应尽量少，如配置N+1个线程的线程池；</li>
<li>IO密集型任务：由于IO操作速度远低于CPU速度，那么在运行这类任务时，CPU绝大多数 时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高CPU利用率，如2*N；</li>
<li>混合型任务：可以拆分为CPU密集型任务和IO密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java多线程基础]]></title>
        <id>https://philosopherzb.github.io/post/java-duo-xian-cheng-ji-chu/</id>
        <link href="https://philosopherzb.github.io/post/java-duo-xian-cheng-ji-chu/">
        </link>
        <updated>2020-12-18T08:13:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java中关于多线程的基础知识，几种创建线程的方式以及线程安全性</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/sea-g5a284195e_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="多线程基础">多线程基础</h2>
<h3 id="java多线程并发库">java多线程并发库</h3>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230227001.png" alt="img" loading="lazy"></figure>
<h3 id="进程与线程">进程与线程</h3>
<p>进程：是程序运行以及资源分配的基本单位，一个程序至少有一个进程。</p>
<p>线程：是CPU调度和分配的基本单位，一个进程至少有一个线程。同一个进程中的线程共享其资源（减少切换，可提高效率），且可以并发执行（并发：同一时间间隔可以做多件事；并行：同一时刻可以做多件事（多核））。</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230227002.png" alt="img" loading="lazy"></figure>
<h3 id="线程的上文切换">线程的上文切换</h3>
<ul>
<li>一个CPU核在任意时刻只能执行一个线程，如果有多个线程（超过CPU核数）存在，CPU将会采用时间片轮转的方式进行线程切换，即给每一个线程分配一个时间片，当一个线程的时间片用完的时候便会处于就绪状态，并让出CPU给其他线程使用，这就是一次上下文切换。</li>
<li>上下文切换时是通过运行时数据区中的程序计数器来存储各个线程的运行状态的，以便于下次运行线程时可以接着上次指令继续运行（比如线程A做了一次计算准备返回数据时，切换到了线程B，然后又切回线程A，是直接返回数据，而不是再去计算一遍）。</li>
<li>程序计数器指的是JVM中的一块内存区域，它可以看作是当前线程所执行字节码的行号指示器，通过它，Java可以知道每个线程执行到了哪一步指令（由此可以看出程序计数器是线程私有的）。</li>
<li>一般而言，上下文切换是比较耗费CPU时间的一种操作。</li>
</ul>
<h3 id="线程的几种状态">线程的几种状态</h3>
<ul>
<li>创建：指的是生成线程对象，此时并没有调用start方法。</li>
<li>就绪：调用线程的start方法后，线程便进入了就绪状态，此时等待系统调度。</li>
<li>运行：通过系统调度，开始运行线程中的run函数。</li>
<li>等待：调用了Object.wait()会进入等待队列。一般需要等待其他线程做出一些特定的通知或者中断。</li>
<li>超时等待：该状态与等待状态有一点区别就是它会自动返回，比如调用Threa.sleep(long)，在超时之后，会自动返回进入就绪状态。</li>
<li>阻塞：指的是去获取锁时(等待进入synchronized方法或块)，发现同步锁被占用了，这时线程会被放入锁池，等待获取锁。</li>
<li>死亡：运行完run方法，main方法（main方法指的是主线程）之后正常退出，也有可能出现异常导致死亡；死亡的线程不能重新启用，否则报错。</li>
</ul>
<h2 id="创建线程的几种方式">创建线程的几种方式</h2>
<h3 id="继承thread">继承Thread</h3>
<pre><code>public class ThreadTest {
    public static void main(String[] args){
        new TestThread().start();
    }
}

class TestThread extends Thread{
    @Override
    public void run(){
        System.out.println(&quot;Test Thread&quot;);
    }
}
</code></pre>
<h3 id="实现runnable">实现Runnable</h3>
<pre><code>public class ThreadTest {
    public static void main(String[] args){
        new Thread(new TestRunnable()).start();
    }
}

class TestRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println(&quot;Test Runnable&quot;);
    }
}
</code></pre>
<h3 id="实现callable">实现Callable</h3>
<pre><code>public class ThreadTest {
    public static void main(String[] args){
        FutureTask&lt;Integer&gt; task = new FutureTask(new TestCallable());
        new Thread(task).start();
        try {
            System.out.println(task.get());//get方法会得到call执行完之后的值
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

class TestCallable implements Callable&lt;Integer&gt; {
    @Override
    public Integer call() throws Exception {
        int num = 0;
        while(num &lt; 5){
            num++;
        }
        return num;
    }
}
</code></pre>
<h2 id="线程安全性">线程安全性</h2>
<ul>
<li>原子性：同一时刻只允许一个线程对数据进行操作（atomic开头的原子类,synchronized，Lock）。</li>
<li>可见性：一个线程对共享变量的修改，可以及时地被其他线程观察到，（synchronized,volatile，Lock）。</li>
<li>有序性：指的是可以观察到其他线程的指令执行顺序，由于指令重排，一般情况下是无序的（happens-before原则）。</li>
</ul>
<h3 id="线程死锁">线程死锁</h3>
<h4 id="死锁">死锁</h4>
<ul>
<li>指的是多个线程在执行过程中，因争夺资源而陷入环路阻塞的一种现象。</li>
<li>示例代码如下（运行之后，两个线程陷入死锁中，如果没有外力中断，将会一直锁定）：</li>
</ul>
<pre><code>public class ThreadTest {
    //共享资源A
    private static final Object A = new Object();
    //共享资源B
    private static final Object B = new Object();

    public static void main(String[] args){
        new Thread(() -&gt; {
            synchronized (A){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---B&quot;);
                synchronized (B){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                }
            }
        },&quot;Thread-01&quot;).start();

        new Thread(() -&gt; {
            synchronized (B){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---A&quot;);
                synchronized (A){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                }
            }
        },&quot;Thread-02&quot;).start();
    }
}
</code></pre>
<h4 id="死锁四个必要条件以及如何避免死锁">死锁四个必要条件以及如何避免死锁</h4>
<ul>
<li>互斥条件：一个资源在任意时刻只能被一个线程占用，如果有其他线程请求该资源，需要等待原线程释放资源（此条件不能被破坏，因为锁本身就是为了互斥访问）。</li>
<li>请求和保持条件：一个线程已经获取了一部分资源，又去请求其他资源，如果其他资源正被占用，原线程陷入阻塞，且不会释放自己占用的资源（一次性申请所有资源；或者阻塞时，释放自己占用的资源）。</li>
<li>不可剥夺条件：一个线程已经获得的资源，在自己未使用完之前不能被其他线程剥夺，只能自己使用结束后释放（如果去获取正在被其他线程使用的资源而阻塞时，可以释放自己占用的资源）。</li>
<li>环路等待条件：多个进程之间形成一种头尾相接的循环等待资源关系（按一定的顺序来获取资源）。</li>
<li>针对上述例子而言，可以让现线程1先获取资源AB，执行完之后，再让线程2获取资源AB，改动如下（执行顺序为：线程1先获取资源A，接着释放CPU，线程2执行准备去获取资源A，发现资源A已被占用，此时线程2阻塞，然后一秒之后释放CPU，线程1接着执行，去获取资源B，正常获取，执行完毕，释放CPU；线程2开始获取资源A，由于线程1已经执行完毕释放了锁，所以线程2正常获取资源A，接着休眠一秒释放CPU，然后又去获取资源B，同样正常获取，执行完毕）：</li>
</ul>
<pre><code>public class ThreadTest {
    //共享资源A
    private static final Object A = new Object();
    //共享资源B
    private static final Object B = new Object();

    public static void main(String[] args){
        new Thread(() -&gt; {
            synchronized (A){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---B&quot;);
                synchronized (B){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                }
            }
        },&quot;Thread-01&quot;).start();

        new Thread(() -&gt; {
            //线程2去获取A时被阻塞
            synchronized (A){
                System.out.println(Thread.currentThread().getName() + &quot;：得到资源---A&quot;);
                try {
                    Thread.sleep(1000);//此处休眠是为了让其他线程获得执行机会
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;：去获取资源---B&quot;);
                synchronized (B){
                    System.out.println(Thread.currentThread().getName() + &quot;：得到资源---B&quot;);
                }
            }
        },&quot;Thread-02&quot;).start();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java集合基础知识]]></title>
        <id>https://philosopherzb.github.io/post/java-ji-he-ji-chu-zhi-shi/</id>
        <link href="https://philosopherzb.github.io/post/java-ji-he-ji-chu-zhi-shi/">
        </link>
        <updated>2020-11-19T06:50:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java中的集合，list，set，map等结构。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/beach-418742_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="接口继承关系和实现">接口继承关系和实现</h2>
<h3 id="集合类概念">集合类概念</h3>
<p>集合类存放于java.util包中，主要有三种，set（集），list（列表包含Queue），map（映射）。</p>
<p>Collection：集合类的通用接口，直接继承接口有List和Set。</p>
<p>Iterator：一个轻量级对象（创建代价小），主要用来对集合进行遍历移除等操作。</p>
<p>Map：使用键值对存储的容器，映射表的基础接口。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301010.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301011.png" alt="img" loading="lazy"></figure>
<h3 id="list">List</h3>
<p>有序集合，是一个非常常用的数据类型，它的实现类有ArrayList，Vector以及LinkedList。</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301012.png" alt="img" loading="lazy"></figure>
<p>ArrayList：底层数据结构是一个数组，查询效率比较高，添加删除较慢（默认添加在末尾，在指定位置添加元素效率比较低，因为需要将指定位置后续的元素都往后移位）。</p>
<p>Vector：与ArrayList基本一致，唯一的差别就是其操作为同步（加了锁），即某一个时刻只有一个线程能够写Vector，这也导致其查询效率比ArrayList慢。</p>
<p>LinkedList：底层数据结构是一个双向链表（prev指向前节点，next指向后节点），查询效率比较慢，添加删除比较快。另外，它还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当做堆栈，队列和双向队列来使用。</p>
<h3 id="set">Set</h3>
<p>Set注重独一无二的性质，其特点是无序且不能出现重复值。对象的相等性本质是由对象的hashCode值（java是根据对象的内存地址计算出的此序号）判断的。如果两个对象相等，则其hashCode以及equals比较结果必然相等。</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301013.png" alt="img" loading="lazy"></figure>
<p>HashSet（hash表）：哈希表中存放的是哈希值，hashSet存储元素并不是按照存入时的顺序（无序），而是按照哈希值来存的，故其取数据也是依据哈希值。元素的哈希值是通过元素的hashCode方法获取的。</p>
<p>hashSet判断两个元素相等：先判断两个元素的哈希值是否相等，如果哈希值一样，再比较equals方法，如果返回true则两个元素相等，否则不相等。</p>
<p>hashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素（equals结果为false）。</p>
<p>TreeSet（二叉树）：会对插入的元素进行排序（依据二叉树）。如果是自定义的类需要进行排序，需要自定义类实现Comparable，覆写对应的compareTo()函数，并返回相应的值。</p>
<p>LinkHashSet（hashSet+LinkedHashMap）：其继承于HashSet，底层使用LinkedHashMap保存数据。</p>
<h3 id="map">Map</h3>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301014.png" alt="img" loading="lazy"></figure>
<p>hashTable（线程安全）：是一个遗留类，与hashMap类似，只是加了全局锁，保证了多线程下的安全。现在已不建议使用，如果需要线程安全，推荐使用ConcurrentHashMap。</p>
<p>TreeMap（可排序）：实现了SortedMap接口，能够将其保存的记录按键进行排序（默认升序）。</p>
<p>LinkHashMap（有序）：hashMap+双向链表，是hashMap的一个子类，保存了记录的插入顺序，在使用Iterator遍历时，先得的数据必然是先插入的（有序），不过也可以对其进行设置，关键参数为accessOrder（true则是访问顺序，false则是插入顺序）。</p>
<h4 id="hashmap">hashMap</h4>
<p>hashMap（数组+链表+红黑树）：根据键的hashCode值存储数据。非线程安全（Collections的synchronizedMap以及ConcurrentHashMap可实现线程安全），允许空键值，执行效率相对较高。</p>
<p>capacity：当前数组容量，始终保持2^n，可以扩容，扩容后数组大小为当前的2倍。</p>
<p>loadFactor：负载因子，默认为0.75。其大小决定了散列表空间的稀密度（越大，越密集，链表越长，索引越慢；越小，越稀疏，链表越短，索引越快）。</p>
<p>threshold：扩容阈值，等于capacity * loadFactor</p>
<p>Java7中，hashMap结构如下：</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301015.png" alt="" loading="lazy"></figure>
<p>Java8中，hashMap结构如下：</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301016.png" alt="" loading="lazy"></figure>
<h4 id="concurrenthashmap">ConcurrenthashMap</h4>
<p>ConcurrenthashMap：相比于hashMap而言，它是线程安全的，其余基本一致。java7中，使用的是分段锁（Segment，默认并行度16）；java8中使用的是节点锁（粒度更细，且引入了红黑树）。</p>
<p>Java7中，ConcurrenthashMap结构如下：</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301017.png" alt="" loading="lazy"></figure>
<p>Java8中，ConcurrenthashMap结构如下：</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301018.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础知识]]></title>
        <id>https://philosopherzb.github.io/post/java-ji-chu-zhi-shi/</id>
        <link href="https://philosopherzb.github.io/post/java-ji-chu-zhi-shi/">
        </link>
        <updated>2020-10-14T07:12:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java中面向对象的三大特性，基本数据结构，六大基本原则。作为博客的第一篇文章，略显简单，不过对于我而言，却是向前迈出了一大步。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/flowers-g5952415a3_1280.jpg" alt="img" loading="lazy"></figure>
<h2 id="面向对象的三大特性">面向对象的三大特性</h2>
<h3 id="封装">封装</h3>
<ul>
<li>将现实中的客观事物封装成抽象的类。</li>
<li>对一个类中的变量，方法进行访问符修饰，以达到有些变量，方法对外开放，有些变量，方法隐藏。</li>
<li>针对第2点对应的访问修饰符有(范围从大到小)：public &gt; protected &gt; default &gt; private。</li>
<li>由于封装隐藏了具体实现，仅提供接口供外部调用，所以在一定程度上可以提高安全性。</li>
</ul>
<h3 id="继承">继承</h3>
<ul>
<li>可以实现已存在的类的变量，方法（非private），并可以扩展单属于自我的变量及方法。</li>
<li>继承在Java中为单继承，即一个子类只能继承一个父类（可以实现多个接口）。</li>
<li>通过继承创建的类称为“子类”，“派生类”。</li>
<li>被继承的类称为“父类”，“基类”，“超类”。</li>
<li>继承的关系是is-a，比如说老师是人，狮子是动物等。</li>
<li>继承可以降低代码的重复性，方便后续对公共行为的维护，不过同时也增加了代码的耦合度。</li>
<li>子类不继承父类的构造器，而是显示或隐式的调用（如果父类中存在不带参构造器，则子类隐式调用该构造器；否则如果父类中仅存在带参构造器，则子类需要通过super来显示调用父类带参构造器）。</li>
</ul>
<h3 id="多态">多态</h3>
<ul>
<li>对同一个行为体现出不同的表现形式，比如吃，可以吃饭，吃零食等。</li>
<li>在Java中体现为对方法的重写以及重载，即传入参数来决定做哪一种具体的动作（重载）不同类之间同一方法不同表现（重写）。</li>
<li>重写一般为父子类之间对方法的不同操作，重载一般为同一个类中对方法的不同操作。</li>
</ul>
<h2 id="基本数据类型四个整数两个浮点一个字符一个布尔">基本数据类型（四个整数，两个浮点，一个字符，一个布尔）</h2>
<ul>
<li>byte，占8位，1字节，默认值：0，包装类：java.lang.Byte</li>
<li>short，占16位，2字节，默认值：0，包装类：java.lang.Short</li>
<li>int，占32位，4字节，默认值：0，包装类：java.lang.Integer</li>
<li>long，占64位，8字节，默认值：0L，包装类：java.lang.Long</li>
<li>float，占32位，4字节，默认值：0.0f，包装类：java.lang.Float</li>
<li>double，占64位，8字节，默认值：0.fd，包装类：java.lang.Double</li>
<li>char，可以存储任何字符，包装类：java.lang.Character</li>
<li>boolean，默认值：false，包装类：java.lang.Boolean</li>
</ul>
<h2 id="面向对象的六大基本原册">面向对象的六大基本原册</h2>
<h3 id="单一职责原则single-responsibility-priciple">单一职责原则（Single Responsibility Priciple）</h3>
<ul>
<li>对于一个类而言，应该只有一个引起他变化的原因。</li>
<li>比如，不要将teacher,doctor都放在一个person类中，而是将其拆成teacher类，doctor类。</li>
<li>能够一定程度上降低耦合度。</li>
</ul>
<h3 id="开闭原则open-close-priciple">开闭原则（Open Close Priciple）</h3>
<ul>
<li>对于扩展是开放的，对于修改是关闭的。</li>
<li>一般来说就是不要修改之前的代码，可以选择继承或者实现接口来扩展对应的功能。</li>
</ul>
<h3 id="里式替换原则liskov-substitution-priciple">里式替换原则（Liskov Substitution Priciple）</h3>
<ul>
<li>所有引用父类的地方都可以透明的使用其子类对象。</li>
<li>即父类出现的地方，把父类换成子类不会出现异常或错误；反之，子类出现的地方，把子类换成父类可能会出现异常或错误。</li>
<li>比如,person类具有eat功能，那么将person.eat换成teacher.eat是没有问题的；而如果teacher类具有独特的teach功能，那么如果将teacher.teach换成person.teach就会出现错误。</li>
</ul>
<h3 id="依赖倒置原则dependence-inversion-priciple">依赖倒置原则（Dependence Inversion Priciple）</h3>
<ul>
<li>高层模块不依赖低层模块，而是应该依赖其抽象</li>
<li>抽象不依赖于细节，细节依赖于抽象</li>
<li>比如teacher类中应该尽量做一些老师共有的抽象行为，比如教书，这样后面的语文老师，数学老师等可以继承该抽象老师类进行扩展。</li>
</ul>
<h3 id="接口隔离原则interface-segregation-priciple">接口隔离原则（Interface Segregation Priciple）</h3>
<ul>
<li>客户端不应该依赖它不需要的接口;一个类对另一个类的依赖应该建立在最小的接口上</li>
<li>尽量一个接口只实现一个功能，如果接口功能太多可进行拆分。</li>
</ul>
<h3 id="迪米特原则law-of-demeter-or-least-knowlegde-priciple">迪米特原则（Law of Demeter or Least Knowlegde Priciple）</h3>
<ul>
<li>一个对象应该对其他对象有最少的了解。</li>
<li>此原则与接口隔离原则可以结合使用，尽量保持一个方法一个具体行为，而不要涵盖多个行为。</li>
</ul>
]]></content>
    </entry>
</feed>