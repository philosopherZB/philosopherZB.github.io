<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://philosopherzb.github.io</id>
    <title>Philosopher</title>
    <updated>2023-03-03T02:55:43.038Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://philosopherzb.github.io"/>
    <link rel="self" href="https://philosopherzb.github.io/atom.xml"/>
    <subtitle>WORLD AS CODE</subtitle>
    <logo>https://philosopherzb.github.io/images/avatar.png</logo>
    <icon>https://philosopherzb.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Philosopher</rights>
    <entry>
        <title type="html"><![CDATA[zabbix5.4采集日志进行钉钉告警]]></title>
        <id>https://philosopherzb.github.io/post/zabbix54-cai-ji-ri-zhi-jin-xing-ding-ding-gao-jing/</id>
        <link href="https://philosopherzb.github.io/post/zabbix54-cai-ji-ri-zhi-jin-xing-ding-ding-gao-jing/">
        </link>
        <updated>2022-01-22T02:28:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述zabbix5.4采集日志进行钉钉告警</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/landscape-1192669_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="配置钉钉机器人">配置钉钉机器人</h2>
<p>电脑版钉钉，选中对应的钉钉群，点击群设置---&gt;智能群助手---&gt;添加机器人---&gt;自定义---&gt;添加。</p>
<p>安全设置根据需要自行选择（演示选择的是自定义关键词），需要记住对应的Webhook（用作python脚本调接口使用）</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302016.png" alt="img" loading="lazy"></figure>
<h2 id="配置zabbix">配置zabbix</h2>
<h3 id="zabbix-server配置">zabbix-server配置</h3>
<p>使用命令查找对应的告警配置文件目录。</p>
<pre><code>cat /etc/zabbix/zabbix_server.conf | grep AlertScripts
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303001.png" alt="" loading="lazy"></figure>
<pre><code>find / -name alertscripts
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303002.png" alt="" loading="lazy"></figure>
<p>找到告警目录后，使用cd命令，切入该目录，并执行vi dingding.py。</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303003.png" alt="" loading="lazy"></figure>
<p>dingding.py内容如下（钉钉文档：<a href="https://developers.dingtalk.com/document/app/custom-robot-access">点击此处跳转页面</a>）</p>
<pre><code>#!/usr/bin/env python3.8
#coding:utf-8
#zabbix dingding alert
import requests,json,sys,os,datetime
webhook=&quot;https://oapi.dingtalk.com/robot/send?access_token=******&quot;
user=sys.argv[1]
text=sys.argv[3]
data={
    &quot;msgtype&quot;: &quot;text&quot;,
    &quot;text&quot;: {
        &quot;content&quot;: text
    },
    &quot;at&quot;: {
        &quot;atMobiles&quot;: [
            user
        ],
        &quot;isAtAll&quot;: False
    }
}
headers = {'Content-Type': 'application/json'}
x=requests.post(url=webhook,data=json.dumps(data),headers=headers)
print(x.status_code)
print(x.text)

</code></pre>
<p>注意：代码的第一句（#!/usr/bin/env python3.8）中的 python3.8取决于系统安装的python版本，使用whereis  python进行查看。</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303004.png" alt="" loading="lazy"></figure>
<p>随后使用如下命令进行权限设置（如若未设置，将无法执行脚本文件）</p>
<pre><code>[root@localhost alertscripts]# chmod 755 dingding.py 
[root@localhost alertscripts]# chown zabbix.zabbix dingding.py

</code></pre>
<p>测试时，前两个参数，随便填，最后的文本内容需要加上在钉钉机器人配置时设置的关键词。</p>
<pre><code>[root@localhost alertscripts]# ./dingding.py 123 wrq &quot;{monitor,test}&quot;
200
{&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303005.png" alt="" loading="lazy"></figure>
<p>问题：可能出现一些安装包不存在，比如requests，使用pip3 list 查看安装了哪些包。如果没有安装requests，可以执行pip3 install requests进行安装。</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303006.png" alt="img" loading="lazy"></figure>
<h3 id="zabbix-web配置">zabbix-web配置</h3>
<h4 id="在已添加的主机上在创建一个监控项">在已添加的主机上在创建一个监控项</h4>
<p>logrt[&quot;/var/log/testlog/^zabbix.[0-9]{8}.[0-9]{1}.log$&quot;,,,,skip,]<br>
表示匹配/var/log/testlog/zabbix20210715.0.log文件进行日志信息采集。</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303007.png" alt="img" loading="lazy"></figure>
<h4 id="在已添加的主机上在创建一个触发器">在已添加的主机上在创建一个触发器</h4>
<p>find(/zabbix-agent/logrt[&quot;/var/log/testlog/^zabbix.[0-9]{8}.[0-9]{1}.log$&quot;,,,,skip,],#10,,&quot;HIGH&quot;)=1<br>
表示匹配/var/log/testlog/zabbix20210715.0.log文件中的HIGH字段进行告警触发。</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303008.png" alt="img" loading="lazy"></figure>
<h4 id="在管理界面添加一个媒体类型">在管理界面添加一个媒体类型</h4>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303009.png" alt="img" loading="lazy"></figure>
<h4 id="在配置界面的动作操作中添加一个触发器动作">在配置界面的动作操作中添加一个触发器动作</h4>
<p>条件选择触发器名称匹配。</p>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303010.png" alt="" loading="lazy"></figure>
<p>随后点击操作</p>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303011.png" alt="" loading="lazy"></figure>
<pre><code>配置信息如下：
业务告警（monitor）
主机: {HOST.NAME1}
时间: {EVENT.DATE} {EVENT.TIME}
级别: {TRIGGER.SEVERITY}
触发器: {TRIGGER.NAME}
监控器: {ITEM.NAME1}; {ITEM.KEY1}
监控内容: {ITEM.VALUE}（{ITEM.LASTVALUE}）
状态: {TRIGGER.STATUS}
项目：{TRIGGER.KEY1} 
事件ID：{EVENT.ID}
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303012.png" alt="" loading="lazy"></figure>
<pre><code>故障恢复（monitor）
主机: {HOST.NAME1}
时间: {EVENT.DATE} {EVENT.TIME}
级别: {TRIGGER.SEVERITY}
触发器: {TRIGGER.NAME}
监控器: {ITEM.NAME1}; {ITEM.KEY1}
监控内容: {ITEM.VALUE}（{ITEM.LASTVALUE}）
状态: {TRIGGER.STATUS}
项目：{TRIGGER.KEY1} 
事件ID：{EVENT.ID}
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303013.png" alt="" loading="lazy"></figure>
<p>上述操作中，需要注意的是Send to users选项，该选项对应的值需与媒体类型关联。比如上面选择的用户是Admin，那么需要在管理界面选择用户Admin进行媒体类型的添加。</p>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230303014.png" alt="" loading="lazy"></figure>
<h4 id="拼接地址调转zabbix指定界面">拼接地址调转zabbix指定界面</h4>
<pre><code>// 拼接地址调转zabbix指定界面
String t = &quot;http://localhost:8096/index.php?request=zabbix.php%3Faction%3Dhost.dashboard.view%26hostid%3D10435&amp;name=Admin&amp;password=zabbix&amp;autologin=1&amp;enter=Sign+in&quot;;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WSL2 & Docker & Zabbix]]></title>
        <id>https://philosopherzb.github.io/post/wsl2-and-docker-and-zabbix/</id>
        <link href="https://philosopherzb.github.io/post/wsl2-and-docker-and-zabbix/">
        </link>
        <updated>2022-01-08T07:31:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述如何安装wsl2，docker以及zabbix。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/forest-1072828_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="install-wsl-update-to-wsl2">Install WSL &amp; update to WSL2</h2>
<p>WSL，全名：Windows Subsystem for Linux，是一个运行在windows系统上的Linux子系统，它支持绝大部分的Linux功能，避免了安装虚拟机。</p>
<h3 id="安装前的一些必要项">安装前的一些必要项</h3>
<p>确保计算机开启了虚拟化技术这项配置，开机进入BIOS界面，选择configuration-》Intel Virtual Technology进行开启即可。</p>
<p>使用WSL2的系统版本必须为windows10，且对应的最低版本要求如下（win+R，输入winver回车即可查看本机系统版本）：</p>
<ul>
<li>For x64 systems: Version 1903 or higher, with Build 18362 or higher.</li>
<li>For ARM64 systems: Version 2004 or higher, with Build 19041 or higher</li>
<li>Builds版本低于 18362 是不支持 WSL 2的。 <a href="https://www.microsoft.com/zh-cn/software-download/windows10">点击此处可跳转下载地址</a> 下载最新的windows进行更新。</li>
</ul>
<h3 id="安装wsl">安装WSL</h3>
<p>以管理员的权限打开powershell（右击左下角的win logo选择即可），键入如下命令：</p>
<pre><code>dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
</code></pre>
<p>命令执行之后，重启电脑即可完成WSL的安装。</p>
<p>下载WSL2最新的安装包进行更新。<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">点击此处可跳转下载地址</a></p>
<p>下载完成后，双击运行即可。</p>
<p>将wsl2设置为默认版本，输入命令：wsl --set-default-version 2</p>
<h3 id="安装liunx操作系统">安装Liunx操作系统</h3>
<p><a href="https://aka.ms/wslstore">点击此处可跳转下载地址</a>选择一款系统点击get进行安装。</p>
<p><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302008.png" alt="img" loading="lazy"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302009.png" alt="" loading="lazy"></p>
<p>等待计算机自动安装完成后，左击桌面左下角的win logo，选择刚刚安装的操作系统。第一次进入需要等待几分钟，随后创建一个用户即可登录使用了。</p>
<p>点击左下方任务栏上的搜索按钮，在搜索框中输入“终端”，选择虚拟机打开。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302010.png" alt="" loading="lazy"></figure>
<p>可以在powershell中的键入wsl --list --verbose查看版本信息</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302011.png" alt="img" loading="lazy"></figure>
<p>额外：可以安装Windows Terminal，便于多界面管理终端。<a href="https://docs.microsoft.com/en-us/windows/terminal/get-started">点击此处可跳转下载地址</a></p>
<p>wls官方地址：<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">点击此处可跳转</a></p>
<p>启动报错时可参考：<a href="https://appuals.com/wsl-fails-to-start-error-4294967295/">点击此处可跳转</a></p>
<h2 id="docker-desktop-for-windows">Docker desktop for windows</h2>
<h3 id="安装docker">安装Docker</h3>
<p>安装完WSL2后，<a href="https://docs.docker.com/docker-for-windows/wsl/#download">点击此处可跳转下载地址</a>下载docker安装包，随后直接双击安装即可。</p>
<p>注意1：docker默认安装在C盘目录下，如果需要迁移，需要进行如下操作：</p>
<p>以管理员身份打开cmd窗口，然后运行命令：mklink /j &quot;C:\Program Files\Docker&quot; &quot;D:\Program Files\Docker&quot;，在此之前要先创建&quot;D:\Program Files\Docker&quot;目录。最后安装docker即可。（ mklink /j 表示创建一个链接）</p>
<p>注意2：docker镜像文件默认存储在wsl中，也就是系统盘，可以通过如下命令进行迁移（需要先创建对应的文件目录D:\Program Files\wsl\data）。</p>
<pre><code>-- 导出文件
wsl --export docker-desktop-data &quot;D:\Program Files\wsl\data\docker-desktop-data.tar&quot;
wsl --export docker-desktop &quot;D:\Program Files\wsl\data\docker-desktop.tar&quot;
-- 注销原来的文件
wsl --unregister docker-desktop
wsl --unregister docker-desktop-data
-- 数据导入新文件中
wsl --import docker-desktop-data &quot;D:\Program Files\wsl\data&quot; &quot;D:\Program Files\wsl\data\docker-desktop-data.tar&quot; --version 2
wsl --import docker-desktop &quot;D:\Program Files\wsl\data&quot; &quot;D:\Program Files\wsl\data\docker-desktop.tar&quot; --version 2
</code></pre>
<p>注意3：在docker的设置界面，需要开启与虚拟机的集成。</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302012.png" alt="img" loading="lazy"></figure>
<h2 id="zabbix54">Zabbix5.4</h2>
<h3 id="安装zabbix">安装zabbix</h3>
<p>在docker中安装监控工具zabbix，操作步骤如下（官网地址：<a href="https://www.zabbix.com/documentation/current/manual/installation/containers">点击此处可跳转</a>）：</p>
<h4 id="创建docker容器专用网关">创建docker容器专用网关</h4>
<pre><code>docker network create --subnet 172.20.0.0/16 --ip-range 172.20.240.0/20 zabbix-net
docker network create -d bridge zabbix-net
</code></pre>
<h4 id="运行一个空的mysql80服务实例">运行一个空的mysql8.0服务实例</h4>
<p>注意：` 符号为windows中powershell下的换行符，位于ESC键下方</p>
<pre><code>docker run --name mysql-server -t `
      -e MYSQL_DATABASE=&quot;zabbix&quot; `
      -e MYSQL_USER=&quot;zabbix&quot; `
      -e MYSQL_PASSWORD=&quot;zabbix_pwd&quot; `
      -e MYSQL_ROOT_PASSWORD=&quot;root_pwd&quot; `
      --network=zabbix-net `
      -d mysql:8.0 `
      --character-set-server=utf8 --collation-server=utf8_bin
</code></pre>
<h4 id="运行zabbix-java-gateway实例版本为ubuntu-latest">运行zabbix-java-gateway实例，版本为ubuntu-latest</h4>
<p>版本标签含义如下：</p>
<p>latest: 基于Alpine Linux镜像的zabbix组件最终稳定版本（如果docker pull的时候不输入TAG，将会默认使用该标签）</p>
<p>alpine-latest: 基于Alpine Linux镜像的zabbix组件最终稳定版本</p>
<p>ubuntu-latest: 基于Ubuntu镜像的zabbix组件最终稳定版本</p>
<p>alpine-5.4-latest: 基于Alpine Linux镜像的zabbix5.4组件最终次要版本</p>
<p>ubuntu-5.4-latest: 基于Ubuntu镜像的zabbix5.4组件最终次要版本</p>
<p>alpine-5.4.*: 基于Alpine Linux镜像的zabbix5.4组件不同次要版本, * 表示不同的子版本，如5.4.1, 5.4.2</p>
<p>ubuntu-5.4.*: 基于Ubuntu镜像的zabbix5.4组件不同次要版本, * 表示不同的子版本，如5.4.1, 5.4.2</p>
<pre><code>docker run --name zabbix-java-gateway -t `
      --network=zabbix-net `
      --restart unless-stopped `
      -d zabbix/zabbix-java-gateway:ubuntu-latest
</code></pre>
<h4 id="运行zabbix-server-mysql服务并将其与mysql服务关联">运行zabbix-server-mysql服务，并将其与mysql服务关联</h4>
<p>注意：zabbix服务实例向主机公开10051/TCP端口（Zabbix Trapper）</p>
<pre><code>docker run --name zabbix-server-mysql -t `
      -e DB_SERVER_HOST=&quot;mysql-server&quot; `
      -e MYSQL_DATABASE=&quot;zabbix&quot; `
      -e MYSQL_USER=&quot;zabbix&quot; `
      -e MYSQL_PASSWORD=&quot;zabbix_pwd&quot; `
      -e MYSQL_ROOT_PASSWORD=&quot;root_pwd&quot; `
      -e ZBX_JAVAGATEWAY=&quot;zabbix-java-gateway&quot; `
      --network=zabbix-net `
      --link mysql-server:mysql `
      -p 10051:10051 `
      --restart unless-stopped `
      -d zabbix/zabbix-server-mysql:ubuntu-latest
</code></pre>
<h4 id="运行zabbix-web-nginx-mysql服务并将其与mysql及zabbix-server-mysql关联">运行zabbix-web-nginx-mysql服务，并将其与mysql及zabbix-server-mysql关联</h4>
<p>注意：至此zabbix服务已在本机的8096端口暴露。</p>
<p>在docker镜像中nginx的默认端口是8080而非80，可进入镜像的/etc/zabbix/nginx.conf查看，命令如下：</p>
<pre><code>docker ps
sudo docker exec -it --user root CONTAINER ID  /bin/bash
cd /etc/zabbix
cat nginx.conf
</code></pre>
<pre><code>docker run --name zabbix-web-nginx-mysql -t `
      -e ZBX_SERVER_HOST=&quot;zabbix-server-mysql&quot; `
      -e DB_SERVER_HOST=&quot;mysql-server&quot; `
      -e MYSQL_DATABASE=&quot;zabbix&quot; `
      -e MYSQL_USER=&quot;zabbix&quot; `
      -e MYSQL_PASSWORD=&quot;zabbix_pwd&quot; `
      -e MYSQL_ROOT_PASSWORD=&quot;root_pwd&quot; `
      --network=zabbix-net `
      --link mysql-server:mysql `
      --link zabbix-server-mysql:zabbix-server `
      -p 8096:8080 `
      --restart unless-stopped `
      -d zabbix/zabbix-web-nginx-mysql:ubuntu-latest
</code></pre>
<h4 id="运行zabbix-agent服务并关联zabbix-server配置在同一个网桥下">运行zabbix-agent服务，并关联zabbix-server（配置在同一个网桥下）</h4>
<p>注意：web界面Configuration中的Hosts配置中的Name必须与/etc/zabbix/zabbix_agentd.conf中的hostName保持一致，命令如下：</p>
<pre><code>docker ps
# root权限进入
sudo docker exec -it --user root CONTAINER ID  /bin/bash
cd /etc/zabbix
cat zabbix_agentd.conf

web界面Configuration中的Hosts配置中的IP address为zabbix-agent容器所在的地址，命令如下：
docker network ls
docker network inspect NETWORK ID（指第一步中创建zabbix-net对应的id值）
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302013.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302014.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302015.png" alt="" loading="lazy"></figure>
<pre><code>docker run --name zabbix-agent `
      -e ZBX_HOSTNAME=&quot;zabbix-agent&quot; `
      -e ZBX_SERVER_HOST=&quot;zabbix-server-mysql&quot; `
      -e ZBX_SERVER_PORT=10051 `
      --network=zabbix-net `
      --link zabbix-server-mysql:zabbix-server-mysql `
      -p 10050:10050 `
      -d zabbix/zabbix-agent:ubuntu-latest

显示所有ip地址
docker inspect -f '{{.Name}} - {{.NetworkSettings.IPAddress }}' $(docker ps -aq)
显示zabbix-agen ip地址
docker inspect -f '{{.Name}} - {{.NetworkSettings.IPAddress }}' zabbix-agent
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用命令]]></title>
        <id>https://philosopherzb.github.io/post/linux-chang-yong-ming-ling/</id>
        <link href="https://philosopherzb.github.io/post/linux-chang-yong-ming-ling/">
        </link>
        <updated>2021-12-18T03:25:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Linux中常用的一些操作命令。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/mountains-440520_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="scp传输文件">SCP（传输文件）</h2>
<p>将win10 D盘temp目录下的文件传输到199.199.199.199的root目录下。</p>
<pre><code>scp D:\temp\***.tar root@199.199.199.199:/root

</code></pre>
<p>将199.199.199.199的root目录下文件传输到win10 D盘temp目录</p>
<pre><code>scp root@199.199.199.199:/root/***.txt D:\temp\

</code></pre>
<h2 id="tar解压缩">TAR（解压缩）</h2>
<p>压缩指定目录下的文件（注意：win为 \，linux为 /）</p>
<pre><code>tar -cvzf  D:\temp\***.tar &quot;D:\temp\***&quot;
# -l   压 缩文件时，把LF字符 置换成LF+CR字 符。
# -ll   压 缩文件时，把LF+CR字 符置换成LF字符。
tar -cvzf -ll  D:\temp\***.tar &quot;D:\temp\***&quot;

</code></pre>
<p>解压指定目录下的文件到指定目录（注意：win为 \，linux为 /）</p>
<pre><code> tar -zxvf /root/***.tar -C /opt/temp/

</code></pre>
<h2 id="mv移动文件">MV（移动文件）</h2>
<p>移动目录下的所有文件至指定目录下</p>
<pre><code>mv  /root/temp/*       /opt/temp/

</code></pre>
<h2 id="find-whereis查询文件">FIND $ WHEREIS（查询文件）</h2>
<p>查询文件</p>
<pre><code>find / -name agent
whereis agent
</code></pre>
<h2 id="dos2unix转换格式">DOS2UNIX（转换格式）</h2>
<p>在win系统中写的shell脚本移动至linux执行时，会提示错误：line 2: $'\r': command not found，这是因为win系统下的换行符为\r\n，而linux系统的为\n，所以需要进行格式转换。</p>
<p>单个，或多个文件格式转换</p>
<pre><code>dos2unix filename1, filename2
</code></pre>
<p>将指定目录下的所有sh结尾的文件进行格式转换</p>
<p>注意：一定要有{}，标示参数；以“;”结尾； {} 和\之间一定要有一个空格</p>
<pre><code>find /apps/cws -name &quot;*.sh&quot; -exec dos2unix {} \;   

</code></pre>
<p>也可以使用xargs命令，不过xargs命令需要和管道符结合使用，并且xargs命令将所有的传入的数据当作一个参数处理。</p>
<pre><code>find /opt/temp/ -name &quot;*.sh&quot; | xargs dos2unix
</code></pre>
<h2 id="ps进程状态process-status">PS（进程状态process status）</h2>
<p>显示所有进程信息，连同命令行</p>
<pre><code>ps -ef
</code></pre>
<p>列出目前正在内存中的程序</p>
<pre><code>ps aux
</code></pre>
<p>通过指定名称列出当前正在内存中的程序的状态(grep命令用于查找符合条件的字符串)</p>
<pre><code>ps aux | grep name
</code></pre>
<h2 id="top任务管理器">TOP（任务管理器）</h2>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p>
<pre><code>top
</code></pre>
<h2 id="sudo操作命令">SUDO（操作命令）</h2>
<p>用于切换用户</p>
<pre><code># 切换至root用户登录
sudo -i
</code></pre>
<h2 id="rz传输文件">RZ（传输文件）</h2>
<p>使用finalshell软件时，在命令窗口输入rz可以直接选择外部文件传入服务器。</p>
<pre><code>rz
</code></pre>
<h2 id="firewall防火墙">Firewall（防火墙）</h2>
<pre><code># 安装防火墙
yum install firewalld firewalld-config
</code></pre>
<pre><code>Firewall开启常见端口命令：

firewall-cmd --zone=public--add-port=80/tcp --permanent

firewall-cmd --zone=public--add-port=443/tcp --permanent

firewall-cmd --zone=public --add-port=22/tcp--permanent

firewall-cmd --zone=public --add-port=9000/tcp --permanent

firewall-cmd --zone=public--add-port=53/udp --permanent

Firewall关闭常见端口命令：

firewall-cmd --zone=public--remove-port=80/tcp --permanent

firewall-cmd --zone=public--remove-port=443/tcp --permanent

firewall-cmd --zone=public--remove-port=22/tcp --permanent

firewall-cmd --zone=public--remove-port=21/tcp --permanent

firewall-cmd --zone=public--remove-port=53/udp --permanent

批量添加区间端口：

firewall-cmd --zone=public--add-port=4400-4600/udp --permanent

firewall-cmd --zone=public--add-port=4400-4600/tcp --permanent

开启防火墙命令：

systemctl start firewalld.service

重启防火墙命令：

firewall-cmd --reload  或者   service firewalld restart

查看端口列表：

firewall-cmd --permanent --list-port
firewall-cmd --list-all

禁用防火墙：

systemctl stop firewalld

设置开机启动：

systemctl enable firewalld

停止并禁用开机启动：

sytemctl disable firewalld

查看状态：

systemctl status firewalld或者firewall-cmd --state

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos7基本知识]]></title>
        <id>https://philosopherzb.github.io/post/centos7-ji-ben-zhi-shi/</id>
        <link href="https://philosopherzb.github.io/post/centos7-ji-ben-zhi-shi/">
        </link>
        <updated>2021-12-04T03:18:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Centos7系统相关的操作及命令介绍。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/lake-1802337_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="图形命令切换">图形/命令切换</h2>
<h3 id="图形界面进入命令行">图形界面进入命令行</h3>
<p>右击或者在application中打开终端，输入：init 3，即可进入命令行；也可以直接ctrl+alt+f2，进入命令行。</p>
<h3 id="命令行进入图形界面">命令行进入图形界面</h3>
<p>输入：init 5或者：startx，即可进入图形界面。</p>
<p>不过由 startx 再进入命令行会无法进入，可以重新输入：init 5，</p>
<p>重启一下x window，然后再输入：init 3，便可进入命令行。</p>
<h3 id="设置开机进入x-window还是命令行">设置开机进入x window还是命令行</h3>
<p>命令行状态下，root管理员，键入：cat /etc/inittab，</p>
<p>根据提示输入：systemctl get-default，可查看当前进入为那种状态。</p>
<p>如若需要更改可以输入：systemctl set-default multi-user.target------命令行</p>
<p>systemctl set-default graphical.target------图形界面</p>
<h2 id="日期相关">日期相关</h2>
<p>1、指令太长的时候，可以使用反斜杠 () 来跳脱[Enter]符号，使指令连续到下一 行。注意！反斜杠后就立刻接回车，才能跳脱。</p>
<p>2、linux区分大小写！！！</p>
<p>3、ls -al 列出『自己家目录(~)』下的『所有隐藏档不相关的文件属性』</p>
<p>4、显示当前语系：echo $LANG</p>
<p>5、日期：date(正常显示)，date +%y/%m/%d(年月日显示)，date +%H:%M(时钟显示)</p>
<p>6、万年历：cal [month][year]</p>
<p>7、计算器：bc，如需显示小数，在键入bc之后，输入：scale=4,（数字4表示小数有4位）退出键入：quit</p>
<p>8、在指令列模式里面下达指令时，会有两种主要的情况：</p>
<ul>
<li>一种是该指令会直接显示结果然后回到命令提示字符等待下一个指令的输入；</li>
<li>一种是进入到该指令的环境，直到结束该指令才回到命令提示字符的环境。</li>
</ul>
<h2 id="常用快捷键">常用快捷键</h2>
<p>1、Tab键，可进行 [[命令补全]] 和 [[档案补齐]]</p>
<ul>
<li>比如在ca后面连续按两下  Tab，即可查看补全的命令。</li>
<li>而档案补齐可以在 ls -al /.bash后面连续按两下Tab，可进行查看。</li>
</ul>
<p>2、Ctrl+C组合键，即先按下Ctrl不放，再按下C键，便可终止运行的命令。</p>
<p>比如：键入：find / 之后会不停的搜寻，此时，可以使用Ctrl+C来终止运行；不过如果是在进行很重要的指令，则不要急着使用组合键终止命令。</p>
<p>3、Ctrl+D组合键，相当于exit，如果使用，可直接退出文字接口。</p>
<p>4、使用man（manual 操作说明的简写），当需要知道某一个命令的详细指令的时候可以使用。比如：man date，如需退出，按下q即可，翻页按空格键。</p>
<p>5、当使用man date之后，界面左上角会出现DATE(1)，其中的括号中的1的概念如下：</p>
<ul>
<li>1 用户在shell环境中可以操作的指令或可执行文件（重要）</li>
<li>2 系统核心可呼叫的函数与工具等</li>
<li>3 一些常用的函数(function)与函式库(library)，大部分为C的函式库(libc)</li>
<li>4 装置档案的说明，通常在/dev下的档案</li>
<li>5 配置文件或者是某些档案的格式 （重要）</li>
<li>6 游戏(games)</li>
<li>7 惯例与协议等，例如Linux文件系统、网络协议、ASCII code等等的说明</li>
<li>8 系统管理员可用的管理指令 （重要）</li>
<li>9 跟kernel有关的文件</li>
</ul>
<p>6、在man page页面可有如下快捷键操作：</p>
<pre><code>空格键              向下翻一页

[Page Down]    向下翻一页

[Page Up]         向上翻一页

[Home]            去到第一页

[End]                去到最后一页

/string              向『下』搜寻 string 这个字符串，如果要搜寻 date 的话，就输入 /date

?string              向『上』搜寻 string 这个字符串

n, N                  利用 / 或 ? 来搜寻字符串时，可以用 n 来继续下一个搜寻 (不论是 / 或?) ，

可以利用 N 来进行『反向』搜寻。举例来说，我以 /date 搜寻 date 字符串，

那么可以 n 继续往下查询，用 N 往上查询。 若以 ?date 向上查询 date 字符串，

那我可以用 n 继续『向上』 查询，用 N 反向查询。

q                      结束这次的 man page
</code></pre>
<p>7、查看与【man】这个指令相关的的说明文件：</p>
<p>命令行键入：man -f man   等同于whatis man</p>
<p>8、利用关键词将说明文件里面只要含有man那个字眼的(不见得是完整字符串) 就将他取出：命令行键入：man -k man  等同于apropos man</p>
<h2 id="infopage及nano">InfoPage及nano</h2>
<p>1、info page</p>
<pre><code>info与man的用途其实差不多，都是用来查询指令的用法或者是档案的格式。

但是与man page一口气输出一堆信息不同的是，info page则是将文件数据拆成

一个一个的段落，每个段落用自己的页面来撰写， 并且在各个页面中还有类似网

页的『超链接』来跳到各不同的页面中，每个独立的 页面也被称为一个节点(node)

命令行键入：info info
</code></pre>
<p>2、出现的第一行里面的数据意义为：</p>
<pre><code>File：代表这个info page的资料是来自info.info档案所提供的；

Node：代表目前的这个页面是属亍Top节点。 意思是info.info内

含有很多信息，而Top仅是 info.info档案内的一个节点内容而已；

Next：下一个节点的名称为Getting Started，你也可以按『N』到下个节点去；

Up：回到上一层的节点总揽画面，你也可以按下『U』回到上一层；

Prev：前一个节点。但由于Top是info.info的第一个节点，所以上面没有前一个节点的信息
</code></pre>
<p>3、info page页面快捷键操作：</p>
<pre><code>空格键                 向下翻一页

[Page Down]       向下翻一页

[Page Up]            向上翻一页

[tab]                    在 node 之间移劢，有 node 的地方，通常会以 * 显示。

[Enter]                 当光标在 node 上面时，按下 Enter 可以进入该 node 。

b                         移动光标到该 info 画面当中的第一个 node 处

e                         移动光标到该 info 画面当中的最后一个 node 处

n                         前往下一个 node 处

p                         前往上一个 node 处

u                         向上移动一层

s(/)                      在 info page 当中进行搜寻

h                         显示求助选单

?                         指令一览表

q                         结束这次的 info page
</code></pre>
<p>4、说明文档所在地。架设一些其他的服务，或想要利用一整组软件来达成某项功能时</p>
<pre><code>键入：cd /usr/share/doc

即可进入doc文件夹下方，有很多文档的说明。（实践中未找到？？？）
</code></pre>
<p>5、超简单文书编辑器： nano</p>
<pre><code>[ctrl]-G：   取得联机帮助(help)，很有用的！

[ctrl]-X：   离开naon软件，若有修改过档案会提示是否需要储存喔！

[ctrl]-O：   储存档案，若你有权限的话就能够储存档案了；

[ctrl]-R：   从其他档案读入资料，可以将某个档案的内容贴在本档案中；

[ctrl]-W：  搜寻字符串，这个也是径有帮助的指令喔！

[ctrl]-C：   说明目前光标所在处的行数与列数等信息；

[ctrl]-_：    可以直接输入行号，让光标快速移动到该行；

[alt]-Y：    校正语法功能开启或关闭(单击开、再单击关)

[alt]-M：   可以支持鼠标来移动光标的功能
</code></pre>
<p>6、关机</p>
<pre><code>重新启动，关机： reboot, halt, poweroff

键入：man shutdown  查看具体细节。

常用的是：shutdown -h now 立即关机

shutdown -r now  立即重启

init 0           立即关机

init 6           立即重启

reboot         立即重启
</code></pre>
<h2 id="linux文件属性">Linux文件属性</h2>
<p>root登陆后，键入ls -al</p>
<p>-rw-r--r--  1 root  root  2272  Jul  5 09:50  initial-setup-ks.cfg</p>
<p>[权限]  [连结数]  [拥有者]  [群组]  [档案容量]  [ 修改日期 ] [檔名]</p>
<p>1、 第一栏代表这个档案的类型与权限(permission)：</p>
<pre><code>-rw-r--r--    其中一共有十个字符。

第一个字符表示档案类型，第二，三，四表示档案拥有者权限

第五，六，七表示档案所属群组的权限，第八，九，十表示其他人的权限
</code></pre>
<p>2、第一个字符代表这个档案是『目录、档案或链接文件等等』：</p>
<pre><code>当为[ d ]则是目录；

当为[ - ]则是档案；

若是[ l ]则表示为连结档(link file)；

若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；

若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)
</code></pre>
<p>3、接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，</p>
<pre><code>[ r ]代表可读 (read)、

[ w ]代表可写(write)、

[ x ]代表可执行(execute)。

要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已
</code></pre>
<p>4、第二栏表示有多少档名连结到此节点(i-node)</p>
<pre><code>每个档案都会将他的权限与属性记录到文件系统的i-node中，

不过，我们使用的目录树却是使用文件名来记录的， 因此每个档名

就会连结到一个i-node！这个属性记录的，就是有多少不同的档

名连结到相同的一个i-node了。
</code></pre>
<p>5、第三栏表示这个档案(或目录)的『拥有者账号』</p>
<p>6、第四栏表示这个档案的所属群组</p>
<p>7、第五栏为这个档案的容量大小，默认单位为bytes</p>
<p>8、第六栏为这个档案的建档日期或者是最近的修改日期</p>
<pre><code>这一栏的内容分别为日期(月/日)及时间。如果这个档案

被修改的时间距离现在太久了，那么时间部分会仅显示年份而已。

显示完整的时间格式，可以利用ls的选顷，

亦即：『ls -al --full-time』就能够显示出完整的时间格式
</code></pre>
<p>9、第七栏为这个档案的档名</p>
<pre><code>如果档名之前多一个『 . 』，则代表这个档案为『隐藏档』
</code></pre>
<h2 id="设置变更">设置变更</h2>
<p>1、改变所属群组, chgrp</p>
<pre><code>这个指令就是change group的缩写

chgrp [-R] dirname/filename ...

选项与参数：

-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案、目录

都更新成为这个群组之意。常常用在变更某一目录内所有的档案之情况

chgrp users initial-setup-ks.cfg

chgrp testing initial-setup-ks.cfg（错误信息：invalid group name `testing'）

只有当你要改变的那个文件或者目录中有要改变成的对应群组，才能改变，否则报错，找不到

比如此次实例中的群组就在/etc/group中存在root和users群组，但不存在testing群组
</code></pre>
<p>2、改变档案拥有者, chown</p>
<pre><code>这个指令就是change owner的缩写

跟概念群组一样，这里要注意的是， 用户必项是已经存在系统中的账号，

也就是在/etc/passwd 这个档案中有纪录的用户名称才能改变。

chown [-R] 账号名称 档案或目录

chown [-R] 账号名称:组名 档案或目录

选项与参数：

-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案都变更

chown bin initial-setup-ks.cfg

chown还可以顺便直接修改群组的名称，中间使用冒号(也可以使用点)，前面为拥有者，后面为群组

chown bin:users initial-setup-ks.cfg

chown bin.users initial-setup-ks.cfg

有时候需要变更档案的拥有者，最常见的例子就是在复制档案给你之外的其他人时

cp 来源档案 目标文件
</code></pre>
<p>（cp .bashrc .bashrc_test ）</p>
<pre><code>先复制一下，然后在更改复制了的使用者，群组。
</code></pre>
<p>3、改变权限, chmod</p>
<pre><code>权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更

数字类型改变档案权限。

Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的 read/write/execute权限

可以使用数字来代表各个权限，如下

r:4 ，w:2， x:1

每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，

例如当权限为： [rwxrwx---] 分数则是：

owner = rwx = 4+2+1 = 7

group = rwx = 4+2+1 = 7

others= --- = 0+0+0 = 0

符号类型改变档案权限

九个权限分别是(1)user (2)group (3)others三种身份啦！那么我们就可以藉由u, g, o来代表三种身份的权限！

此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r, w, x

其中+表示加入，-表示减去，=表示设定

chmod a+w initial-setup-ks.cfg   设定该档案u，g，o都具有w（写）权限

chmod a-w initial-setup-ks.cfg   设定该档案u，g，o都去掉w（写）权限

chmod u=rwx,go=rw initial-setup-ks.cfg   设定该档案u具有rwx权限，go都具有rw权限
</code></pre>
<p>4、『 su - yy 』这个指令来变换身份，只能进入普通账户，进入root需要重新输入密码</p>
<p>5、『 cat ~/.bashrc 』就可以看到该档案的内容。 (cat 是将一个档案内容读出来的指令)</p>
<p>6、Linux目录配置的依据--FHS（Filesystem Hierarchy Standard 文件系统阶层标准）</p>
<pre><code>主要有以下四个类型：

可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录。

不可分享的：自己机器上面运作的装置档案或者是与程序有关的socket档案等，由与仅与自身机器有关，所以当然就不适合分享给其他主机了。

不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等。

可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等 。
</code></pre>
<p>7、FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义</p>
<pre><code>/ (root, 根目录)：与开机系统有关；

/usr (unix software resource)：与软件安装/执行有关；

/var (variable)：与系统运作过程有关
</code></pre>
<h2 id="目录及文件">目录及文件</h2>
<p>1、相对路径与绝对路径：</p>
<pre><code>绝对路径：路径的写法『一定由根目录 / 写起』，例如： /usr/share/doc 这个目录。

相对路径：路径的写法『不是由 / 写起』，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写：『cd ../man』这就是相对路径的写法啦！相对路径意指『相对于目前工作目录的路径！』
</code></pre>
<p>2、目录的相关操作：</p>
<pre><code>『.』                代表此层目录

『..』               代表上一层目录

『-』               代表前一个工作目录

『~』              代表『目前用户身份』所在的家目录

『~yy』           代表yy这个用户的家目录(yy是个账号名称)
</code></pre>
<p>常见处理目录的指令(可用man查看)：</p>
<pre><code>cd：变换目录              （Change Directory）

pwd：显示当前目录        （Print Working Directory）

-P(大写)  ：显示出确实的路径，而非使用链接 (link) 路径。

mkdir：建立一个新的目录

mkdir [-mp] 目录名

-m ：配置文件案的权限！直接设定，不需要看预设权限 (umask) 的脸色

-p ：帮助你直接将所需要的目录(包含上层目录)递归建立起来

rmdir： 删除一个空的目录

-p ：连同上层『空的』目录也一起删除
</code></pre>
<p>3、执行文件路径的变量： $PATH</p>
<pre><code>a、不同身份使用者预设的PATH不同，默认能够随意执行的指令也不同(如root与yy)

b、PATH是可以修改的，所以一般使用者还是可以通过修改PATH来执行某些位于/sbin或/usr/sbin下的指令来查询

c、使用绝对路径或相对路径直接指定某个指令的文件名来执行，会比搜寻PATH来的正确

d、指令应该要放置到正确的目录下，执行才会比较方便

e、本目录(.)最好不要放到PATH当中
</code></pre>
<p>4、复制、删除与移动： cp, rm, mv</p>
<pre><code>cp (复制档案或目录)

[root@localhost]# cp /.bashrc /tmp/bashrc  &lt;==将.bashrc复制到/tmp下，并更名为bashrc

[root@localhost tmp]# cp /var/log/wtmp .  &lt;==将wtmp复制到当前目录，最后的『.』不要忘了！

在不加任何选项的情况下，档案的某些属性/权限会改变

这是个很重要的特性！而且连档案建立的时间也不一样了！

如果想要将档案的所有特性都一起复制过来，加上 -a 便可以了

[root@localhost tmp]# cp -r /etc/ /tmp     &lt;==如果为目录，则不能直接复制，需加上-r，与此同时，档案与目录的权限也可能会被改变，这个时候可以用『 cp -a /etc /tmp 』来下达指令！尤其是在备份的情况下！
</code></pre>
<p>cp 有种种的文件属性与权限的特性，所以，在复制时，须了解到：</p>
<pre><code>a、是否需要完整的保留来源档案的信息？

b、来源档案是否为连结档 (symbolic link file)？

c、来源档是否为特殊的档案，例如 FIFO, socket 等？

d、来源文件是否为目录？

rm (移除档案或目录)

[root@localhost tmp]# rm -i bashrc  &lt;==加上 -i 选项便会主动询问，避免删除到错误的档名！

[root@localhost tmp]# rm -i bashrc* &lt;==通过通配符『*』的帮忙，将/tmp底下开头为bashrc的档名通通删除。通配符『*』代表的是 0 到无穷多个任意字符。</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IDEA属性及插件配置]]></title>
        <id>https://philosopherzb.github.io/post/idea-shu-xing-ji-cha-jian-pei-zhi/</id>
        <link href="https://philosopherzb.github.io/post/idea-shu-xing-ji-cha-jian-pei-zhi/">
        </link>
        <updated>2021-04-10T11:34:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述IDEA常用的一些配置以及相关插件，搭配使用或可提升编码效率。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/valley-90388_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="idea统一设置">IDEA统一设置</h2>
<p>为保证大家有统一的代码规范和IDE行为，现对IDEA的设置进行统一说明。需要指出的是，下列的IDEA设置，均在默认设置的基础上进行个性化变更的。</p>
<p>使用IDEA的自动格式化，对所有源文件以及配置文件进行格式化后提交。（IDEA默认的快捷键为：Ctrl + Alt + L，mac系统为:command + option + L）。</p>
<p>使用IDEA的优化导入类和包进行import语句的合理排列。（IDEA的默认快捷键为：Ctrl + Alt + O，mac系统为:command + option + O）。</p>
<h3 id="配置类">配置类</h3>
<p>配置类的设置入口为File-&gt;Settings,下面所说的所有配置，都是在这个菜单下进行的。</p>
<h4 id="导包优化配置">导包优化配置</h4>
<p>进行优化导入包时，可能会出现几个通包路径下的类出现折叠成*的情况，这是违反通用编码规约的（存在导错包的情形）。因此，在进行导包优化之前，请设置IDEA的自动折叠功能为999，如下图所示：</p>
<p>依次进入Editor-&gt;Code Style-&gt;Java 将Class count to use import ‘*’这一项后面的数值改为999</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301031.png" alt="img" loading="lazy"></figure>
<h4 id="文件编码配置">文件编码配置</h4>
<p>依次进入Editor-&gt;File Encodings，将所有字符集设置，调整为UTF-8，并且将UTF-8的pom设置为no pom，如下图：</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301032.png" alt="img" loading="lazy"></figure>
<h4 id="换行符统一配置">换行符统一配置</h4>
<p>统一使用Unix风格的换行符，找到Editor-&gt;Code Style-&gt;Line separator，设置成Unix and OS X(\n)</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301033.png" alt="img" loading="lazy"></figure>
<h4 id="个性化配置">个性化配置</h4>
<p>一些个性化的简单配置。</p>
<h5 id="字体配置如下editor-font">字体配置如下Editor-&gt;Font：</h5>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301034.png" alt="" loading="lazy"></figure>
<h5 id="git配置如下version-control-git需要事先安装git找到对应的bin目录即可">git配置如下Version Control-&gt;Git(需要事先安装git，找到对应的bin目录即可)：</h5>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301035.png" alt="" loading="lazy"></figure>
<h5 id="序列化时未引入序列化id报警配置如下editor-inspections">序列化时未引入序列化id报警配置如下Editor-&gt;Inspections：</h5>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301036.png" alt="" loading="lazy"></figure>
<p>类头自动加载注释配置如下Editor-&gt;File and Code Templates：</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301037.png" alt="img" loading="lazy"></figure>
<h3 id="插件类">插件类</h3>
<p>为简化开发步骤，并且让大家在沟通一些插件功能时，可以用统一的语言，现对开发时使用的基本插件进行下列约定，请开发前，在IDEA中安装下列插件。</p>
<h4 id="lombok插件">Lombok插件</h4>
<p>开发过程中，编写JavaBean，需要些大量的get set方法，虽然IDEA有快捷键可以生成这些方法，但是对于整体代码的整洁度，多多少少还是有一些影响。</p>
<p>所以，在开发过程中，我们会大量用到Lombok，在编译期自动生成get set方法，equals方法以及hashcode方法。</p>
<p>该插件，可以自动识别@Data等注解，让代码IDEA能够对自动生成的方法进行导航。并且在编写代码时，能够自动对get,set方法进行提示补全。</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301038.png" alt="img" loading="lazy"></figure>
<h4 id="maven-helper插件">Maven Helper插件</h4>
<p>编写pom过程中，总会遇到各种各样的依赖问题，Maven Helper插件，提供了一种mvn dependency:tree之外的解决方案。</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301039.png" alt="" loading="lazy"></figure>
<p>安装插件后，在打开pom文件，可以看到多了Dependency Analyzer标签。</p>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301040.png" alt="" loading="lazy"></figure>
<p>可以方便地找到冲突的依赖,并且支持以图形化的形式查看依赖树。</p>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301041.png" alt="img" loading="lazy"></figure>
<h4 id="free-mybatis-plugin插件">Free Mybatis plugin插件</h4>
<p>用于Mybatis接口与xml文件的快速跳转。安装插件后，可以在接口中直接跳转到对应mybatis xml配置文件的对应方法上。</p>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301042.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301043.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301044.png" alt="" loading="lazy"></figure>
<h4 id="alibaba-java-coding-guidelines插件">Alibaba Java Coding Guidelines插件</h4>
<p>使用“Alibaba Java Coding Guidelines”，插件，对工程下所有代码进行扫描。一期暂定消除所有Blocker与Critial的错误，同时Major的错误不得超过50个。</p>
<p>在有些情况下，必然会产生警告（比如无法避免的泛型转原始类型），在确认不会产生意外错误时，使用@SuppressWarning 来抑制警告。若如此做，代码评审时，会对此注解进行重点关注。所以务必确保该注解不被滥用。</p>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301045.png" alt="" loading="lazy"></figure>
<p>直接右击项目，选择编码规约扫描</p>
<figure data-type="image" tabindex="17"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301046.png" alt="img" loading="lazy"></figure>
<h4 id="findbugs插件">FindBugs插件</h4>
<p>对工程下所有代码进行扫描，检查存在的bug。<a href="https://plugins.jetbrains.com/plugin/3847-findbugs-idea/versions">点击此处跳转下载页面</a></p>
<figure data-type="image" tabindex="18"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301047.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301048.png" alt="" loading="lazy"></figure>
<p>find-sec-bugs为FindBugs-IDEA的扩展库，可以增加额外的扫描结果。<a href="https://find-sec-bugs.github.io/download.htm">点击此处跳转下载页面</a></p>
<figure data-type="image" tabindex="20"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301049.png" alt="img" loading="lazy"></figure>
<h4 id="visualvm-launcher插件">VisualVM Launcher插件</h4>
<p>运行java程序的时候启动visualvm，方便查看jvm的情况 比如堆内存大小的分配</p>
<p>某个对象占用了多大的内存，jvm调优必备工具。</p>
<figure data-type="image" tabindex="21"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301050.png" alt="" loading="lazy"></figure>
<p>配置如下：</p>
<figure data-type="image" tabindex="22"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301051.png" alt="" loading="lazy"></figure>
<p>使用如下：</p>
<figure data-type="image" tabindex="23"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301052.png" alt="img" loading="lazy"></figure>
<h4 id="jclasslib插件">jclasslib插件</h4>
<p>查看java字节码插件，相比于命令行的javap -v className更加方便。直接在idea的插件中搜索并下载即可。</p>
<figure data-type="image" tabindex="24"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301053.png" alt="" loading="lazy"></figure>
<p>使用时，先选择需要查看字节码的java类，之后选择View -&gt; Show Bytecode With jclasslib即可打开字节码视图。</p>
<figure data-type="image" tabindex="25"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301054.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="26"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301055.png" alt="img" loading="lazy"></figure>
<h4 id="bashsupport插件">bashsupport插件</h4>
<p>支持bash编码，智能提示。</p>
<figure data-type="image" tabindex="27"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301056.png" alt="" loading="lazy"></figure>
<p>配置启动项，选择git安装目录中的bash.exe即可。</p>
<figure data-type="image" tabindex="28"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301057.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="29"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301058.png" alt="" loading="lazy"></figure>
<p>编写完成后，直接右击run便可看到执行结果。</p>
<figure data-type="image" tabindex="30"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301059.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中的常用排序算法]]></title>
        <id>https://philosopherzb.github.io/post/java-zhong-de-chang-yong-pai-xu-suan-fa/</id>
        <link href="https://philosopherzb.github.io/post/java-zhong-de-chang-yong-pai-xu-suan-fa/">
        </link>
        <updated>2021-03-13T02:46:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述java中常用的一些排序算法极其实现代码，如二分查找，快速排序，堆排，归并排序，冒泡排序等。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/lake-192979_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="java中的常用算法">Java中的常用算法</h2>
<h3 id="术语说明及排序图表">术语说明及排序图表</h3>
<p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面（如果我们只对一串数字排序，那么稳定与否确实不重要，因为一串数字的属性是单一的，就是数字值的大小。但是排序的元素往往不只有一个属性，例如我们对一群人按年龄排序，但是人除了年龄属性还有身高体重属性，在年龄相同时如果不想破坏原先身高体重的次序，就必须用稳定排序算法.）；</p>
<p>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
<p>内排序：所有排序操作都在内存中完成；</p>
<p>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p>时间复杂度： 一个算法执行所耗费的时间。</p>
<p>空间复杂度：运行完一个程序所需内存的大小。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302005.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302006.png" alt="img" loading="lazy"></figure>
<h3 id="二分查找">二分查找</h3>
<p>又称折半查找，要求待查找的列表有序，每次取中间位置的值与待查关键字比较，如果中间位置的值比关键字大，则在列表前半部分循环此查找过程，否则在列表后半部分循环此查找过程。</p>
<pre><code>public static void main(String[] args) {
    // 正常二分查找
    int[] array = {1, 2, 3, 4, 5, 6};
    int a = 3;
    System.out.println(binarySerach(array, a));

    // 寻找左侧边界的二分查找
    int[] array_left = {1, 2, 2, 4, 4, 6};
    int a_left = 2;
    System.out.println(binarySerachForLeftBound(array_left, a_left));

    // 寻找右侧边界的二分查找
    int[] array_right = {1, 2, 2, 5, 5, 6};
    int a_right = 5;
    System.out.println(binarySerachForRightBound(array_right, a_right));
}

/**
 * 二分查找,如果存在，则输出待查找数据在数组中的下标值，否则返回-1
 *
 * @param numbers 指定查询数组
 * @param target  待查找数据
 * @return 查找结果
 */
private static int binarySerach(int[] numbers, int target) {
    int low = 0;
    int high = numbers.length - 1;
    int middle;
    // 此处用 &lt;= 是因为high = numbers.length - 1
    // 如果high = numbers.length，则此处需要使用 &lt;,同时返回结果需要更改为 return numbers[low] == target ? low : -1;
    while (low &lt;= high) {
        // (low + high)/2，如果low + high大于Integer的MAX_VALUE会发生整型溢出
        // 使用low + (high - low) / 2可以防止整型溢出。
        middle = low + (high - low) / 2;
        // 匹配目标值，返回其在数组中所在的下标
        if (numbers[middle] == target) {
            return middle;
        } else if (numbers[middle] &gt; target) {
            high = middle - 1;
        } else if (numbers[middle] &lt; target) {
            low = middle + 1;
        }
    }
    return -1;
}

/**
 * 寻找左侧边界的二分查找,如果存在，则输出待查找数据在数组中最左侧的下标值，否则返回-1
 *
 * @param numbers 指定查询数组
 * @param target  待查找数据
 * @return 查找结果
 */
private static int binarySerachForLeftBound(int[] numbers, int target) {
    int low = 0;
    int high = numbers.length - 1;
    int middle;
    // 此处用 &lt;= 是因为high = numbers.length - 1
    // 如果high = numbers.length，则此处需要使用 &lt;,同时返回结果需要更改为 return numbers[low] == target ? low : -1;
    while (low &lt;= high) {
        // 匹配返回下标
        if (numbers[low] == target) {
            return low;
        }
        // (low + high)/2，如果low + high大于Integer的MAX_VALUE会发生整型溢出
        // 使用low + (high - low) / 2可以防止整型溢出。
        middle = low + (high - low) / 2;
        // 匹配目标值，将其下标赋给high，往左侧缩小边界
        if (numbers[middle] == target) {
            high = middle;
        } else if (numbers[middle] &gt; target) {
            high = middle - 1;
        } else if (numbers[middle] &lt; target) {
            low = middle + 1;
        }
    }
    return -1;
}

/**
 * 寻找左侧边界的二分查找,如果存在，则输出待查找数据在数组中最右侧的下标值，否则返回-1
 *
 * @param numbers 指定查询数组
 * @param target  待查找数据
 * @return 查找结果
 */
private static int binarySerachForRightBound(int[] numbers, int target) {
    int low = 0;
    int high = numbers.length - 1;
    int middle;
    // 此处用 &lt;= 是因为high = numbers.length - 1
    // 如果high = numbers.length，则此处需要使用 &lt;,同时返回结果需要更改为 return numbers[low] == target ? low : -1;
    while (low &lt;= high) {
        // (low + high)/2，如果low + high大于Integer的MAX_VALUE会发生整型溢出
        // 使用low + (high - low) / 2可以防止整型溢出。
        middle = low + (high - low) / 2;
        // 匹配目标值，将其下标+1赋给low，往右侧边界缩小
        if (numbers[middle] == target) {
            low = middle + 1;
        } else if (numbers[middle] &gt; target) {
            high = middle - 1;
        } else if (numbers[middle] &lt; target) {
            low = middle + 1;
        }
    }
    // 匹配返回下标
    return numbers[high] == target ? high : -1;
}

</code></pre>
<h3 id="冒泡排序">冒泡排序</h3>
<p>比较前后相邻的两个的数据，如果前面数据大于后面数据，则将两个数据所在位置交换。步骤如下（以从小到大为例）：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<pre><code>public static void main(String[] args) {
    int[] numbers = {4, 2, 5, 3, 7, 9, 1};
    bubbleSort3(numbers);
    for (int number : numbers) {
        System.out.println(number);
    }
}

// 从小到大
private static void bubbleSort(int[] numbers) {
    if (numbers.length == 0) {
        return;
    }
    for (int i = 0; i &lt; numbers.length; i++) {
        for (int j = 0; j &lt; numbers.length - 1 - i; j++) {
            if (numbers[j] &gt; numbers[j + 1]) {
                int temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
            }
        }
    }
}

// 优化，去掉多余排序
private static void bubbleSort2(int[] numbers) {
    if (numbers.length == 0) {
        return;
    }
    for (int i = 0; i &lt; numbers.length; i++) {
        // 排序标识
        boolean isSorted = true;
        for (int j = 0; j &lt; numbers.length - 1 - i; j++) {
            if (numbers[j] &gt; numbers[j + 1]) {
                int temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
                // 存在交换过程，继续排序
                isSorted = false;
            }
        }
        if (isSorted) {
            break;
        }
    }
}

//从大到小
private static void bubbleSort3(int[] numbers) {
    if (numbers.length == 0) {
        return;
    }
    for (int i = numbers.length - 1; i &gt; 0; i--) {
        for (int j = numbers.length - 1; j &gt; numbers.length - 1 - i; j--) {
            if (numbers[j] &gt; numbers[j - 1]) {
                int temp = numbers[j];
                numbers[j] = numbers[j - 1];
                numbers[j - 1] = temp;
            }
        }
    }
}

</code></pre>
<h3 id="选择排序">选择排序</h3>
<p>每一次从待排序的数据元素中选出最小（最大）的一个元素，存放在序列的起始（末尾）位置，直到全部待排序数据排完。</p>
<p>选择排序是不稳定的排序方法，比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面。步骤如下：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了</li>
</ul>
<pre><code>public static void main(String[] args) {
    int[] array = {2, 3, 1, 5, 4};
    selectSort(array);
    System.out.println(Arrays.toString(array));
}

private static void selectSort(int[] array) {
    if (array.length == 0) {
        return;
    }
    int minIndex;
    for (int i = 0; i &lt; array.length; i++) {
        minIndex = i;
        for (int j = i + 1; j &lt; array.length; j++) {
            if (array[minIndex] &gt; array[j]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            int temp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = temp;
        }
    }
}

</code></pre>
<h3 id="插入排序">插入排序</h3>
<p>通过构建有序序列，对于未排序的数据，在已排序的数据中从后向前扫描，找到相应的位置并插入。步骤如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<pre><code>public static void main(String[] args) {
    int[] array = {3, 1, 2, 5, 4};
    binaryInsertSort(array);
    System.out.println(Arrays.toString(array));
}

// 直接插入
private static void insertSort(int[] array) {
    for (int i = 1; i &lt; array.length; i++) {
        // 待插入数据
        int insertVal = array[i];
        // 待插入数据的前一个数据
        int insertIndex = i - 1;
        // insertIndex &gt;= 0防止数组越界
        while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; array[insertIndex]) {
            // 如果插入数据比已排序数据要小，则将已排序数据向后移动一位
            array[insertIndex + 1] = array[insertIndex];
            // 同时，让insertIndex向前移动一位
            insertIndex--;
        }
        // 插入指定位置
        array[insertIndex + 1] = insertVal;
    }
}

// 折半插入
private static void binaryInsertSort(int[] array) {
    int temp;
    int low, high, middle;
    for (int i = 1; i &lt; array.length; i++) {
        // 待插入数据
        temp = array[i];
        // 二分查找合适的插入位置
        // 左边默认为已排序
        low = 0;
        // 右边终点取已排序数组的索引
        high = i - 1;
        while (low &lt;= high) {
            // 无符号右移一位，等同于/2
            middle = (low + high) &gt;&gt;&gt; 1;
            if (array[middle] &gt; temp) {
                high = middle - 1;
            } else {
                // 等于的情形包含在此，因为相等的话，插入数据在其左边，右边都是一致的
                low = middle + 1;
            }
        }
        // 已排序的所有数据向后移动
//        for (int j = i - 1; j &gt;= high + 1; j--) {
//            array[j + 1] = array[j];
//        }
        if (i - (high + 1) &gt;= 0) {
            System.arraycopy(array, high + 1, array, high + 1 + 1, i - (high + 1));
        }
        // 插入元素
        array[high + 1] = temp;
    }
}

</code></pre>
<h3 id="希尔排序">希尔排序</h3>
<p>又称缩小增量排序，它按一定的增量（gap=lengh/2 -&gt; gap=gap/2,也称希尔增量）进行分组，对每一组数据进行直接插入排序，直至增量减为1，所有分组再次合并为一个，接着对这个最终分组进行直接插入排序，即可得到排序结果。步骤如下：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<pre><code>public static void main(String[] args) {
    int[] array = {2, 3, 1, 5, 4};
    shellSort(array);
    System.out.println(Arrays.toString(array));
}

// 希尔排序
private static void shellSort(int[] array) {
    if (array.length == 0) {
        return;
    }
    // 无符号右移1位，等同/2
    int gap = array.length &gt;&gt;&gt; 1;
    while (gap &gt; 0) {
        for (int i = gap; i &lt; array.length; i++) {
            // 待插入数据
            int insertVal = array[i];
            // 待插入数据的前一个数据
            int insertIndex = i - gap;
            // insertIndex &gt;= 0防止数组越界
            while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; array[insertIndex]) {
                // 如果插入数据比已排序数据要小，则将已排序数据向后移动一位
                array[insertIndex + gap] = array[insertIndex];
                // 同时，让insertIndex向前移动一位
                insertIndex -= gap;
            }
            // 插入指定位置
            array[insertIndex + gap] = insertVal;
        }
        // 无符号右移1位，等同/2
        gap &gt;&gt;&gt;= 1;
    }
}

</code></pre>
<h3 id="归并排序">归并排序</h3>
<p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。步骤如下：</p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<pre><code>public static void main(String[] args) {
    int[] array = {2, 1, 3, 9, 5, 8, 4, 6};
    System.out.println(Arrays.toString(mergeSort(array)));
}

private static int[] mergeSort(int[] array) {
    // 只有一位或者没有数据时，直接返回原数组
    if (array.length &lt; 2) {
        return array;
    }
    // 无符号右移（此处必为正数，效果与右移一致），等同于/2
    int middle = array.length &gt;&gt;&gt; 1;
    int[] left = Arrays.copyOfRange(array, 0, middle);
    int[] right = Arrays.copyOfRange(array, middle, array.length);
    return merge(mergeSort(left), mergeSort(right));
}

private static int[] merge(int[] left, int[] right) {
    // 合并之后的数组
    int[] result = new int[left.length + right.length];
    for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) {
        // 左侧数组已经全部放入结果数组中,将右侧数组数据直接递增放入
        if (i &gt;= left.length) {
            result[index] = right[j++];
        } else if (j &gt;= right.length) {
            // 右侧数组已经全部放入结果数组中,将左侧数组数据直接递增放入
            result[index] = left[i++];
        } else if (left[i] &gt; right[j]) {
            // 左侧数组中的数据比右侧数组中的数据值大,将右侧数组数据直接放入，随后递增
            result[index] = right[j++];
        } else {
            // 左侧数组中的数据比右侧数组中的数据值小,将左侧数组数据直接放入，随后递增
            result[index] = left[i++];
        }
    }
    return result;
}

</code></pre>
<h3 id="快速排序">快速排序</h3>
<p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>注意：在此过程中需要先选取一个关键值作为基准值，这样比基准值小的都在左边，大的都在右边。步骤如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230302007.png" alt="" loading="lazy"></figure>
<pre><code>public static void main(String[] args) {
    int[] array = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48, 1};
    quickSort(array, 0, array.length - 1);
    System.out.println(Arrays.toString(array));
}

// 填坑法
private static void quickSort(int[] array, int start, int end) {
    if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) {
        return;
    }
    int i = start;
    int j = end;
    // 基准值
    int pivot = array[i];
    // 左右两边同时扫描，直到两者交错
    while (i &lt;= j) {
        // 从右边寻找比基准值小的数
        while (array[j] &gt; pivot) {
            j--;
        }
        // 从左边寻找比基准值大的数
        while (array[i] &lt; pivot) {
            i++;
        }
        // 此处已找到比基准值大的数（左边），比基准值小的数（右边），两者进行交换
        if (i &lt;= j) {
            swap(array, i, j);
            i++;
            j--;
        }
    }
    // 左边再做排序，直到只剩下一个数，则退出递归
    if (start &lt; j) {
        quickSort(array, start, j);
    }
    // 右边再做排序，直到只剩下一个数，则退出递归
    if (end &gt; i) {
        quickSort(array, i, end);
    }
}

private static void swap(int[] array, int i, int j) {
    if (i != j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

</code></pre>
<h3 id="堆排序">堆排序</h3>
<p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。步骤如下：</p>
<ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<pre><code>public static void main(String[] args) {
    int[] array = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48, 1};
    heapSort(array);
    System.out.println(Arrays.toString(array));
}

private static void heapSort(int[] array) {
    int length = array.length;
    if (length &lt; 1) {
        return;
    }
    buildMaxHeap(array, length);
    while (length &gt; 0) {
        swap(array, 0, length - 1);
        length--;
        adjustHeap(array, 0, length);
    }
}

private static void buildMaxHeap(int[] array, int length) {
    // 从最后一个非叶子节点开始向上构建最大堆
    for (int i = (length / 2 - 1); i &gt;= 0; i--) {
        adjustHeap(array, i, length);
    }
}

private static void adjustHeap(int[] array, int i, int length) {
    int maxIndex = i;
    // 如果有左子树，且左子树大于父节点，则将最大指针指向左子树
    if (i * 2 &lt; length &amp;&amp; array[i * 2] &gt; array[maxIndex]) {
        maxIndex = i * 2;
    }
    // 如果有右子树，且右子树大于父节点，则将最大指针指向右子树
    if (i * 2 + 1 &lt; length &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex]) {
        maxIndex = i * 2 + 1;
    }
    // 如果父节点不是最大值，则将父节点与最大值交换，并递归调整与父节点交换的位置
    if (maxIndex != i) {
        swap(array, maxIndex, i);
        adjustHeap(array, maxIndex, length);
    }
}

private static void swap(int[] array, int i, int j) {
    if (i != j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

</code></pre>
<h3 id="计数排序">计数排序</h3>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。步骤如下：</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<pre><code>public static void main(String[] args) {
    int[] array = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48, 1};
    CountingSort(array);
    System.out.println(Arrays.toString(array));
}

private static void CountingSort(int[] array) {
    if (array.length &lt; 1) {
        return;
    }
    int bias, min = array[0], max = array[0];
    for (int i = 1; i &lt; array.length; i++) {
        if (array[i] &gt; max)
            max = array[i];
        if (array[i] &lt; min)
            min = array[i];
    }
    bias = 0 - min;
    int[] bucket = new int[max - min + 1];
    Arrays.fill(bucket, 0);
    for (int anArray : array) {
        bucket[anArray + bias]++;
    }
    int index = 0, i = 0;
    while (index &lt; array.length) {
        if (bucket[i] != 0) {
            array[index] = i - bias;
            bucket[i]--;
            index++;
        } else
            i++;
    }
}

</code></pre>
<h3 id="桶排序">桶排序</h3>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序。</p>
<p>注意：如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。步骤如下：</p>
<ul>
<li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ul>
<pre><code>public static void main(String[] args) {
    Integer[] array = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48, 1};
    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(array.length);
    Collections.addAll(list, array);
    System.out.println(bucketSort(list, array.length));
}

private static ArrayList&lt;Integer&gt; bucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) {
    if (array == null || array.size() &lt; 2)
        return array;
    int max = array.get(0), min = array.get(0);
    // 找到最大值最小值
    for (Integer i : array) {
        if (i &gt; max)
            max = i;
        if (i &lt; min)
            min = i;
    }
    int bucketCount = (max - min) / bucketSize + 1;
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount);
    ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; bucketCount; i++) {
        bucketArr.add(new ArrayList&lt;&gt;());
    }
    for (Integer i : array) {
        bucketArr.get((i - min) / bucketSize).add(i);
    }
    for (int i = 0; i &lt; bucketCount; i++) {
        if (bucketSize == 1) { // 如果带排序数组中有重复数字时
            resultArr.addAll(bucketArr.get(i));
        } else {
            if (bucketCount == 1) {
                bucketSize--;
            }
            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);
            resultArr.addAll(temp);
        }
    }
    return resultArr;
}

</code></pre>
<h3 id="基数排序">基数排序</h3>
<p>基数排序(radix sort)属于&quot;分配式排序&quot;(distribution sort)，又称&quot;桶子法&quot;(bucket sort)或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些&quot;桶&quot;中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。步骤如下：</p>
<ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<pre><code>public static void main(String[] args) {
    int[] array = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48, 1};
    radixSort(array);
    System.out.println(Arrays.toString(array));
}

private static void radixSort(int[] array) {
    if (array == null || array.length &lt; 2) {
        return;
    }
    // 1.先算出最大数的位数；
    int max = array[0];
    for (int i = 1; i &lt; array.length; i++) {
        max = Math.max(max, array[i]);
    }
    int maxDigit = 0;
    while (max != 0) {
        max /= 10;
        maxDigit++;
    }
    int mod = 10, div = 1;
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    for (int i = 0; i &lt; 10; i++) {
        bucketList.add(new ArrayList&lt;&gt;());
    }
    for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) {
        for (int j : array) {
            int num = (j % mod) / div;
            bucketList.get(num).add(j);
        }
        int index = 0;
        for (ArrayList&lt;Integer&gt; buckets : bucketList) {
            for (Integer bucket : buckets) {
                array[index++] = bucket;
            }
            buckets.clear();
        }
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java中引用&IO&类加载&对象创建过程]]></title>
        <id>https://philosopherzb.github.io/post/java-zhong-yin-yong-andioandlei-jia-zai-anddui-xiang-chuang-jian-guo-cheng/</id>
        <link href="https://philosopherzb.github.io/post/java-zhong-yin-yong-andioandlei-jia-zai-anddui-xiang-chuang-jian-guo-cheng/">
        </link>
        <updated>2021-03-06T08:10:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java中的四种引用类型，JavaIO类型（BIO，NIO，AIO），Java类加载机制以及Hotspot JVM虚拟机对象的探究。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/boat-1014711_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="四种引用">四种引用</h2>
<h3 id="强引用">强引用</h3>
<p>把一个对象复制给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，这时，GC不会对其进行回收（造成OOM的主要原因之一）。</p>
<pre><code>// 强引用
String str = &quot;test&quot;;
// 取消强引用
str = null;

</code></pre>
<h3 id="软引用">软引用</h3>
<p>软引用需要使用SoftReference类来实现，对于软引用对象来说，当系统内存足够时不会对其进行回收，反之则进行回收。通常应用在对内存敏感的程序中。</p>
<pre><code>// 软引用
SoftReference&lt;String&gt; softReference = new SoftReference&lt;&gt;(&quot;test&quot;);

</code></pre>
<h3 id="弱引用">弱引用</h3>
<p>弱引用需要使用WeakReference类来实现，它比软引用生存周期更短，对于弱引用对象来说，只要垃圾回收机制一运行，不管JVM内存空间是否充足，都会对其进行回收。</p>
<pre><code>// 弱引用
WeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(&quot;test&quot;);

</code></pre>
<h3 id="虚引用">虚引用</h3>
<p>虚引用需要使用PhantomReference类来实现，它不能单独使用，必须与引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。</p>
<pre><code>// 虚引用
ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;&gt;();
PhantomReference&lt;String&gt; pr = new PhantomReference&lt;&gt;(&quot;test&quot;, queue);

</code></pre>
<h2 id="java中的io">Java中的I/O</h2>
<h3 id="bioblock-io">BIO（Block IO）</h3>
<ul>
<li>同步阻塞式IO，一般指平常所用的IO类。</li>
<li>一个请求对应一个响应，为了合理的利用资源，可以使用多线程（线程池）。</li>
<li>此IO一般针对并发量较小的场景（&lt;1000）。</li>
<li>BIO操作的对象是流（Stream）。</li>
<li>比如：在ATM机上取钱，只能一个一个的取，前面有人的时候，需要等待；取钱的时候，需要本人进行相关取钱操作（取出之后拿到钱才走）。</li>
</ul>
<h3 id="nionew-io">NIO（New IO）</h3>
<ul>
<li>同步非阻塞式IO。</li>
<li>利用Channel（通道）通讯，实现了多路复用。</li>
<li>核心组件：Buffer（缓冲区），Channel（通道），Selector（选择器）</li>
<li>NIO操作的对象是缓存区（Buffer）。</li>
<li>基本运行流程：当Channel发生新连接、就绪读，就绪写的时候，首先会在Selector上注册相应的事件，生成一个与Channel绑定的selectKey；其次由一个线程轮询selectKey集合，利用操作系统底层的函数select() 或者 epoll（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是iocp）去操作系统查询IO是否就绪，如果就绪则执行相应的事件处理器（通过selectKey找到Channel，然后利用与Channel绑定的buffer进行实际读写）。</li>
<li>比如：在银行大厅取钱，对于前面是否有人等候，只需要隔一段时间去问一下大堂经理是否可以取钱就可以了，不需要一直去排队（这段时间可以做其他事）；取钱的时候，需要柜员进行相关操作，同时也需要保证你也在柜员面前（不能离开，不然柜员可能会找不到你，然后钱就没有实际拿到手里了）。</li>
</ul>
<h3 id="aioasynchronous-io">AIO（Asynchronous IO）</h3>
<ul>
<li>异步非阻塞式IO。</li>
<li>其实现是基于事件以及回调机制。</li>
<li>AIO与NIO有点相似，不过对于实际读写而言，AIO是交给操作系统底层自己去完成的，完成之后会返回一个IO完成的回调消息。</li>
<li>比如：同样是去银行取钱，不过这次你是让朋友去帮忙取的，你朋友会帮你排队，然后取钱，接着把钱给你，并告诉你已经取好了。</li>
</ul>
<h3 id="io阶段">IO阶段</h3>
<ul>
<li>IO中对于读写一般分为两个阶段：就绪读写（准备数据）以及实际读写（真正读写数据）。</li>
<li>对应上面取钱例子而言，就绪读写指的是排队，实际读写指的是取钱操作。</li>
</ul>
<h3 id="同步异步">同步，异步</h3>
<ul>
<li>同步指的是操作的时候，需要等待当前任务返回结果；异步则相反，它不需要等待当前任务返回，通常情况下是依赖于事件，回调机制来实现任务间的次序关系。</li>
<li>同步，异步对于IO而言指的是实际读写阶段；对应取钱例子而言，就是真正取钱操作（同步，自己取钱；异步，朋友帮忙取钱）。</li>
</ul>
<h3 id="阻塞非阻塞">阻塞，非阻塞</h3>
<ul>
<li>阻塞指的是如果任务在执行，当前线程会阻塞，需要等待任务执行完，这期间该线程不能执行其他任务；非阻塞则是说在一个任务执行期间，线程不会阻塞，可以执行其他任务。</li>
<li>阻塞，非阻塞对于IO而言指的是就绪读写阶段；对应取钱例子而言，就是排队等候（阻塞，排队没带手机，只能干等着；非阻塞，排队带了手机，可以一边玩手机一边排队）。</li>
</ul>
<h2 id="jvm类加载">JVM类加载</h2>
<h3 id="类加载机制">类加载机制</h3>
<p>JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301027.png" alt="img" loading="lazy"></figure>
<p>1、加载：在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口（注意：不一定非得从Class文件中获取，也可以从ZIP（如jar，war）中读取，或者在运行时计算生成（动态代理），或者由其他文件转换而来（如JSP转换为Class））。</p>
<p>2、验证：确保Class文件字节流中所包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>3、准备：正式为类变量分配内存并为其设置初始值，即在方法区中分配这些变量所使用的内存空间。需要注意这里所说的初始值概念，比如说一个类变量定义为：</p>
<pre><code>public static int port = 8080;
</code></pre>
<p>那么此变量在准备阶段所谓的设置初始值，是设置其为0，而不是8080。将port赋值为8080的put static 指令是程序被编译后，存放于类构造器<code>&lt;Client&gt;</code>方法中的。</p>
<p>但如果变量声明如下：</p>
<pre><code>public static final int port = 8080;
</code></pre>
<p>那么在编译期间，会为port生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将port赋值为8080.</p>
<p>4、解析：此阶段指虚拟机将常量池中的符号引用替换为直接引用的过程。</p>
<p>符号引用：与虚拟机实现的布局无关，引用的目标不一定要已经加载至内存中。各种虚拟机的内存布局可以不一致，但它们能接受的符号引用必须一致，因为符号引用的字面量形式明确的定义在java虚拟机规范的Class文件格式中。、</p>
<p>直接引用：是可以直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄，如果存在直接引用，那么引用的目标必定已经在内存中存在。</p>
<p>5、初始化：此阶段开始真正执行类中定义的java程序代码，即开始开始执行类构造器<code>&lt;client&gt;</code>方法。</p>
<p><code>&lt;client&gt;</code>方法是由编译器自动收集类中的类静态变量赋值以及静态语句块中的语句合并而成的。虚拟机会保证子<code>&lt;client&gt;</code>执行之前，父<code>&lt;client&gt;</code>已经执行完毕（如果一个类中既没有类静态变量赋值，也没有静态语句块，那虚拟机可以不为其生成<code>&lt;client&gt;</code>方法）。</p>
<p>注意以下几种情形不会执行类初始化：</p>
<ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化。</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在类的初始化。</li>
<li>通过类名获取Class对象，不会触发初始化。</li>
<li>通过Class.forName加载指定类时，如果指定参数initialize为false（initialize是告诉虚拟机是否要对该类进行初始化），也不会触发类的初始化。</li>
<li>通过ClassLoader默认的loadClass方法，不会触发类初始化。</li>
</ul>
<h3 id="类加载器">类加载器</h3>
<p>类的加载并没有发生在JVM中，而是由应用程序来确定如何获取所需要的类。为此JVM提供了三种类加载器，如下：</p>
<p>1、启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可的类（按文件名识别，如：rt.jar）。</p>
<p>2、扩展类加载器（Extension ClassLoader）：负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</p>
<p>3、应用程序类加载器（Application ClassLoader）：负责加载用户路径（classpath）上的类库。</p>
<h3 id="双亲委派模型">双亲委派模型</h3>
<p>JVM通过双亲委派模型进行类的加载，当然，开发者也可以通过集成java.lang.ClassLoader实现自定义的类加载器。</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301028.png" alt="" loading="lazy"></figure>
<p>双亲委派过程：当一个类收到类加载请求时，它首先不会尝试自己去加载这个类，而是将这个请求委派给父类去完成，每一层次的类加载器都是如此操作，因此所有的类加载请求都应该会传送到启动类加载器中，只有当父加载器无法加载此类时（在它的加载路径下没有找到所需加载的Class），子加载器才会尝试自己去加载。</p>
<p>双亲委派解决了java基础类统一加载的问题，但某些情况下父类加载器需要委托子类加载器去加载Class文件，例如SPI（Service Provider Interface）代码（spi是一种服务发现机制：即为某个接口寻找服务实现的机制。）。</p>
<h3 id="以jdbc为例谈双亲委派模型的破坏">以JDBC为例谈双亲委派模型的破坏</h3>
<p>Java本身有一套资源管理服务JNDI（Java Naming and Directory Interface，根据名称可以在其中查找对应的方法或者其他参数），其放置于rt.jar中，由启动类加载器进行加载。</p>
<p>以数据库管理JDBC为例，java给数据库操作提供了一个Driver（java.sql.Driver）接口，并提供了一个DriverManager（java.sql.DriverManager）来管理Driver的具体实现。</p>
<h4 id="不破坏双亲委派模型不使用jdni">不破坏双亲委派模型（不使用JDNI）</h4>
<pre><code>// 加载数据库驱动
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
// 连接到数据库上去
Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai&quot;,&quot;root&quot;,&quot;root&quot;);

</code></pre>
<p>Class.forName()触发了mysql驱动类的加载，通过源码可以发现，mysql的驱动类已经在静态块中被注册到了DriverManager中，所以后续使用时可以直接建立连接。其核心实现如下：</p>
<pre><code>public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    public Driver() throws SQLException {
    }

    static {
        try {
            DriverManager.registerDriver(new Driver());
        } catch (SQLException var1) {
            throw new RuntimeException(&quot;Can't register driver!&quot;);
        }
    }
}
</code></pre>
<pre><code>public static synchronized void registerDriver(java.sql.Driver driver,
        DriverAction da)
    throws SQLException {

    /* Register the driver if it has not already been added to our list */
    if(driver != null) {
        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));
    } else {
        // This is for compatibility with the original DriverManager
        throw new NullPointerException();
    }

    println(&quot;registerDriver: &quot; + driver);

}

</code></pre>
<h4 id="破坏双亲委派模型使用jdni">破坏双亲委派模型（使用JDNI）</h4>
<p>JDBC4.0以后，开始支持spi注册Driver，具体做法便是在mysql的jar中的META-INF/services/java.sql.Driver文件中指明当前的Driver，然后通过下列方式即可使用。</p>
<pre><code>// 连接到数据库上去
Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai&quot;,&quot;root&quot;,&quot;root&quot;);

</code></pre>
<p>此处相比于不破坏双亲委派模型，少了一句Class.forName()，即加载驱动类的步骤。其对应的Driver是配置在META-INF/services/java.sql.Drive文件中的，由此可以知道其操作为：先从配置文件中读取Driver，随后再进行加载（使用Class.forName()）</p>
<p>需要注意的是，Class.forName()加载的是调用者的ClassLoader，这个调用者DriverManager是在rt.jar中，ClassLoader是启动类加载器，而com.mysql.cj.jdbc.Driver并没有位于&lt;JAVA_HOME&gt;/lib下，所以肯定是无法直接加载到mysql的这个类的。这边是双亲委派的局限性，父类加载器无法加载子类加载器路径中的类（父对子透明，子对父不透明）。</p>
<p>为了让父类加载器加载子类加载器路径中的类，可以通过线程上下文加载器去加载第三方jar包中的Driver，这便打破了双亲委派模型。</p>
<p>以DriverManager为例，当调用其getConnection()方法时，会先执行器静态块中的初始化代码，如下：</p>
<pre><code>/**
 * Load the initial JDBC drivers by checking the System property
 * jdbc.properties and then use the {@code ServiceLoader} mechanism
 */
static {
    loadInitialDrivers();
    println(&quot;JDBC DriverManager initialized&quot;);
}

</code></pre>
<pre><code>AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
    public Void run() {
        // 各个sql厂商在自己的jar包中通过spi注册的驱动
        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);
        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();

        /* Load these drivers, so that they can be instantiated.
         * It may be the case that the driver class may not be there
         * i.e. there may be a packaged driver with the service class
         * as implementation of java.sql.Driver but the actual class
         * may be missing. In that case a java.util.ServiceConfigurationError
         * will be thrown at runtime by the VM trying to locate
         * and load the service.
         *
         * Adding a try catch block to catch those runtime errors
         * if driver not available in classpath but it's
         * packaged as service and that service is there in classpath.
         */
        try{
            while(driversIterator.hasNext()) {
                driversIterator.next();
            }
        } catch(Throwable t) {
        // Do nothing
        }
        return null;
    }
});

</code></pre>
<p>其中ServiceLoader.load()便是拿到线程上下文加载器，并构造了一个ServiceLoader进行返回，如下：</p>
<pre><code>public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}

public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,
                                        ClassLoader loader)
{
    return new ServiceLoader&lt;&gt;(service, loader);
}

</code></pre>
<p>DriverManager中的doPrivileged()中还有一句driversIterator.next()，其中实现了类加载过程，具体实现如下：</p>
<pre><code>private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null;
    Class&lt;?&gt; c = null;
    try {
        // 此处的cn便是便是厂商在META-INF/services/java.sql.Drive文件中配置的全限定驱动类名
        // loader则是上文中ServiceLoader.load()返回的线程上下文加载器。
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {
        fail(service,
             &quot;Provider &quot; + cn + &quot; not found&quot;);
    }
    if (!service.isAssignableFrom(c)) {
        fail(service,
             &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);
    }
    try {
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service,
             &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,
             x);
    }
    throw new Error();          // This cannot happen
}

</code></pre>
<h2 id="hotspot-jvm虚拟机对象探究">Hotspot JVM虚拟机对象探究</h2>
<h3 id="对象的创建以普通java对象new指令为例">对象的创建（以普通Java对象new指令为例）</h3>
<ul>
<li>当虚拟机遇到一条new指令时，首先会去常量池中检查是否存在这个对象的引用，并且检查该引用所代表的类是否已经被加载，解析和初始化过，如果没有，则先执行类加载。</li>
<li>当类加载检查通过之后，虚拟机将会为新生对象分配内存（对象所需的内存大小在类加载完成之后就已经确认了，为对象分配空间就是在Java堆上划分出一块内存来。一般有两种分配方式，根据内存规整程度分为：指针碰撞（规整）以及空闲列表（不规整））。</li>
<li>针对并发情况下对象内存分配冲突解决方案有：一是同步处理，二是使用本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）（虚拟机是否使用本地线程分配缓冲可通过-XX:+/-UseTLAB参数来设定）。</li>
<li>内存分配完毕之后，虚拟机会将对应的内存空间初始化为零值（不包括对象头）。接着会对这个对象进行必要的设置，例如此对象是哪个类的实例，如何查找类的元数据信息，对象的哈希码，对象的GC分代年龄等等，这些信息都放在了对象头中。</li>
<li>执行完new指令之后还需要执行<code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算是完全创建好了。</li>
</ul>
<h3 id="对象的内存布局">对象的内存布局</h3>
<ul>
<li>在HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header），实例数据（Instance Data）以及对齐填充（Padding）。</li>
<li>对象头（Header）主要包含两部分信息：第一部分用于存储对象自身的运行时数据（如哈希码（HashCode），GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据长度在32位或者64位的虚拟机中分别为32bit以及64bit，官方称之为“Mark Word”）；第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机可以通过这个指针来确定该对象属于哪个类的实例（并不是所有的虚拟机实现都需要在对象数据上保留类型指针，即查找对象的元数据信息并不一定要经过对象本身），如果对象是一个Java数组，那么对象头还需要记录该数组长度，因为普通的Java对象可以通过元数据信息确认对象大小，而数组却不行。</li>
<li>实例数据（Instance Data）存储着对象真正有效的信息，即各种类型的字段，无论是继承父类还是子类自定义。</li>
<li>对齐填充（Padding）不是必然存在的，也没有特殊的含义，仅仅起到占位符的作用，保证对象大小是某个字节的整数倍（HotSpot VM 的自动内存管理系统要求对象起始地址必须为8字节的整数倍）。</li>
</ul>
<h3 id="对象的访问定位">对象的访问定位</h3>
<ul>
<li>建立对象的目的是为了使用该对象，Java程序是通过栈上的reference指针来操作堆上的具体对象的。</li>
<li>目前主流的访问方式有句柄和直接指针两种。</li>
</ul>
<h4 id="句柄访问定位">句柄访问定位</h4>
<ul>
<li>使用句柄的话，Java堆将会划分出一块内存来作为句柄池，reference中存放的也就是对象的句柄地址（句柄中包含了对象实例数据和类型数据各自的地址）。</li>
<li>句柄的优势在于其稳定性更高，如果对象频繁的发生移动（GC操作时移动对象），那么只会改变句柄中的实例数据的指针，reference本身不需要改变。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301029.png" alt="img" loading="lazy"></figure>
<h4 id="直接访问定位">直接访问定位</h4>
<ul>
<li>使用直接指针，那么reference将直接指向对象对应的地址（Java堆布局时需要考虑如何存放访问类型数据的相关信息）。</li>
<li>直接指针的优势在于其速度更快，因为减少了一次指针定位的操作。如果对象访问频繁，那么使用直接访问将会提高相当不错的效率。</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301030.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM详解]]></title>
        <id>https://philosopherzb.github.io/post/jvm-xiang-jie/</id>
        <link href="https://philosopherzb.github.io/post/jvm-xiang-jie/">
        </link>
        <updated>2021-02-27T07:44:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述JVM，包括jvm线程，jvm运行时区域，jvm垃圾回收机制--回收算法以及垃圾回收器</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/mountains-139012_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="jvm概述">JVM概述</h2>
<h3 id="基本概念">基本概念</h3>
<p>JVM是运行java代码的虚拟计算机平台，它运行于计算机操作系统之上，并不直接与硬件进行交互。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301019.png" alt="img" loading="lazy"></figure>
<h3 id="运行过程">运行过程</h3>
<p><em>x.java源文件，通过编译器产生对应的</em>.Class字节码文件，之后又通过java虚拟机中的解释器，编译成特定机器上的机器码。</p>
<p>流程如下：</p>
<ul>
<li>Java源文件 ----&gt; 编译器 ----&gt; 字节码文件</li>
<li>字节码文件 ----&gt; JVM解释器 ----&gt; 机器码</li>
</ul>
<p>每一种平台的解释器都是不同的，但其依赖的虚拟机是一样的，这也就是java跨平台运行的核心原理。</p>
<p>虚拟机实例随着程序的运行而启动，程序退出或关闭则会使对应的虚拟机实例消亡。多个程序启动会存在多个虚拟机实例，各个虚拟机实例之间互不干扰，数据独立。</p>
<h2 id="jvm线程">JVM线程</h2>
<h3 id="线程">线程</h3>
<p>此处所说的线程为程序执行过程中的一个线程实体。JVM允许一个应用并发执行多个线程。</p>
<p>Hotspot JVM中的java线程与操作系统原生线程存在直接的映射关系：当java线程创建完毕后，会同步创建一个操作系统原生线程。java线程结束，原生线程也会随之被回收（原生线程由操作系统负责调度，如将其分配至可用的CPU）。</p>
<p>Hotspot JVM 后台运行的系统线程如下图所示：</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301020.png" alt="img" loading="lazy"></figure>
<h2 id="jvm内存区域">JVM内存区域</h2>
<h3 id="内存区域图">内存区域图</h3>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301021.png" alt="img" loading="lazy"></figure>
<h3 id="运行时数据区域">运行时数据区域</h3>
<p>Java虚拟机在执行java程序时，定义了若干程序运行期间会使用到的运行时数据区域，其中线程共享区域随着虚拟机的启动/关闭而创建/销毁，线程私有区域则与用户线程一一对应，会随着用户线程的启动/关闭而创建/销毁（ Hotspot JVM中，用户线程会与原生线程对应）。</p>
<p>运行时数据区域图如下：</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301022.png" alt="img" loading="lazy"></figure>
<h4 id="程序计数器program-counter-register">程序计数器（Program Counter Register）</h4>
<ul>
<li>是一块内存小，线程私有，且不会发生OOM（OutOfMemoryError）的区域（因为它只是当前线程所执行的字节码的行号指示器）。</li>
<li>在Java虚拟机概念模型中（仅仅指概念模型，各类不同的虚拟机可能有更高效的处理方式），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来完成。</li>
<li>Java虚拟机可以支持多线程同时执行（可参考《Java 语言规范》第 17 章），是通过轮转时间片的方式让处理器来执行线程的。在任意时刻，一个处理器（对于多核处理器来说是指一个内核）只会处理一个线程中的指令，为了保证线程切换能够回到正确的执行指令，Java虚拟机针对每个线程分配了一个独立的程序计数器，各线程之间的计数器互不干扰，独立存储。</li>
<li>如果线程正在执行的方法不是 native的（即Java方法），那程序计数器就保存 Java 虚拟机正在执行的字节码指令的地址，如果该方法是 native 的，那程序计数器的值是 undefined。</li>
<li>程序计数器的容量至少应当能保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值。</li>
</ul>
<h4 id="java虚拟机栈java-virtual-machine-stack">Java虚拟机栈（Java Virtual Machine Stack）</h4>
<ul>
<li>Java虚拟机栈是线程私有的，它的生命周期与线程一致。</li>
<li>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</li>
<li>局部变量表存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身)和 returnAddress 类型(指向了一条字节码指令的地址)。</li>
<li>需要注意的是64位的long以及double类型的数据会占用两个局部变量空间（Slot），其余的数据类型只占一个。局部变量表所需的内存空间在编译期间就已经完成了分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是已经确认了的，在方法运行期间不会去改变局部变量表的大小。</li>
<li>Java虚拟机栈有可能发生以下两种异常状况：如果线程请求分配的栈容量（栈深度）超过 Java 虚拟机栈允许的最大容量（深度）时，Java 虚拟机将会抛出一 个StackOverflowError异常；如果Java 虚拟机栈可以动态扩展（目前大部分虚拟机都支持动态扩展），并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 OutOfMemoryError异常。</li>
</ul>
<h4 id="本地方法栈native-method-stack">本地方法栈（Native Method Stack）</h4>
<ul>
<li>本地方法栈与Java虚拟机栈是非常类似的，他们的主要区别是Java虚拟机栈是服务于Java方法（字节码）的，而本地方法栈则是服务于Native方法的。</li>
<li>与Java虚拟机栈一样，本地方法栈同样会出现StackOverflowError异常和OutOfMemoryError异常。</li>
</ul>
<h4 id="java堆java-heap">Java堆（Java Heap）</h4>
<ul>
<li>在 Java 虚拟机中，堆（Heap）是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域，一般而言堆（Heap）占用的内存空间也是最大的。</li>
<li>Java 堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统（Automatic Storage Management System，也即是常说的“Garbage Collector（垃圾收集器）”）所管理的各种对象，这些受管理的对象无需，也无法显式地被销毁。所以一般我们也称Java堆为GC堆（Garbage Collected Heap）。</li>
<li>如果实际所需的堆超过了自动内存管理系统能提供的最大容量（或者说堆中没有内存来完成实例分配，且无法扩展），那 Java 虚拟机将会抛出一个 OutOfMemoryError异常。</li>
</ul>
<h4 id="方法区method-area">方法区（Method Area）</h4>
<ul>
<li>在 Java 虚拟机中，方法区（Method Area）是可供各条线程共享的运行时内存区域。</li>
<li>它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法（即存储着已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据）。</li>
<li>如果方法区的内存空间不能满足内存分配请求，那 Java 虚拟机将抛出一个 OutOfMemoryError异常。</li>
</ul>
<h4 id="运行时常量池runtime-constant-pool">运行时常量池（Runtime Constant Pool）</h4>
<ul>
<li>运行时常量池是方法区（Method Area）的一部分。</li>
<li>它是每一个类或接口的常量池（Constant_Pool）的运行时表示形式，它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。</li>
<li>一般情况下，除了保存Class文件中描述的符号引用外，还会把翻译过来的直接引用也保存在运行时常量池中。</li>
<li>运行时常量池相对于Class文件常量池的另一个特征是具备动态性，即运行期间也可将新的常量放入池中，比如String.intern()方法。</li>
<li>当创建类或接口的时候，如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li>
</ul>
<h4 id="直接内存direct-memory">直接内存（Direct Memory）</h4>
<ul>
<li>直接内存并不属于Java虚拟机运行时内存区域，也不是Java虚拟机规范中定义的内存区域。</li>
<li>在这里提出来的主要原因是因为Java在1.4版本引入了NIO类，是一种基于通道（Channel）和缓存区（Buffer）的IO操作，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</li>
<li>在某些情况下，通过减少Java堆和Native堆来回复制数据的操作，从而提高一些性能。</li>
<li>因为这块内存也是实际存在的，所以受硬件总内存影响，如果需要对虚拟机内存进行扩容操作，需要考虑虚拟机内存加直接内存超过物理内存限制所引起的 OutOfMemoryError异常。</li>
</ul>
<h3 id="jvm运行时内存">JVM运行时内存</h3>
<h4 id="分代">分代</h4>
<p>Java堆从GC角度还可以细分为新生代（Eden区，From Survivor区，To Survivor区），老年代。</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301023.png" alt="img" loading="lazy"></figure>
<h4 id="新生代">新生代</h4>
<p>用于存储初创对象，一般占据堆内存1/3。对象的创建频繁且杂多，所以此区域会经常触发MinorGC进行垃圾回收。</p>
<h5 id="新生代细分区域">新生代细分区域</h5>
<p>Eden区：Java新对象的出生地（如果新创建的对象占用内存过大，将直接被分配至老年代），当Eden内存不足时，将触发一次MinorGC，对其进行垃圾回收。</p>
<p>From Survivor区：上一次GC的幸存者存放在此区域，将作为这一次GC的扫描对象。</p>
<p>To Survivor区：经历一次MinorGC过程的幸存者。</p>
<h5 id="新生代gc过程复制算法">新生代GC过程（复制算法）</h5>
<p>首先将Eden和From Survivor区域中存活的对象复制到To Survivor区域（From Survivor区如果存在对象年龄且大于阈值，则直接复制到老年代），同时将这些对象的年龄+1（如果To Survivor区被填满了，剩余的对象会被复制到老年代中）。随后清空Eden和From Survivor区域中的死对象。最后，将From Survivor和To Survivor调换名字，这样，在下一次GC时，原To Survivor将成为From Survivor。</p>
<h4 id="老年代">老年代</h4>
<p>主要存储应用程序中生命周期较长的内存对象。进入老年代的对象一般都比较稳定，所以不会频繁地执行MajorGC。</p>
<p>MajorGC采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收未标记的对象。此过程耗时较长，且会产生内存碎片。</p>
<h4 id="永久代">永久代</h4>
<p>内存的永久保存区域，主要存放Class以及Meta（元数据）信息。Class在被加载时便放入永久区域，它跟存放实例的区域不同，GC不会在主程序执行期间对永久区域进行清理。所以，这也导致了永久区域随着加载的Class增多而不断膨胀，最终抛出OOM异常。</p>
<p>Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所替代。元空间的本质与永久代类似，它们之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p>
<h3 id="垃圾回收与算法">垃圾回收与算法</h3>
<h4 id="gc算法图">GC算法图</h4>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301024.png" alt="img" loading="lazy"></figure>
<h4 id="垃圾确认算法">垃圾确认算法</h4>
<p>引用计数法：对象被引用则+1，否则-1，为0时将被回收（存在循环引用问题）。</p>
<p>可达性分析：为了避免引用计数法中的循环引用问题，如今java一般采用可达性分析，通过一系列的GC ROOTS（VM栈中的引用，方法区中的静态引用，JNI中的引用等）作为对象的起点搜索。如果GC ROOTS和一个对象之间没有可达路径，则称其为不可达。需要注意的是：不可达对象不等价于可回收对象，不可达对象变为可回收对象最少需要经历两次标记过程，如果仍然不可达，则会面临回收。</p>
<h4 id="垃圾收集算法">垃圾收集算法</h4>
<h5 id="标记清除算法mark-sweep">标记清除算法（Mark-Sweep）</h5>
<p>最基础的垃圾回收算法，分为两个阶段，标记和清除。如下图所示（容易出现内存碎片）：</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301025.png" alt="img" loading="lazy"></figure>
<h5 id="复制算法copying">复制算法（copying）</h5>
<p>为了解决Mark-Sweep算法中内存碎片化的缺陷而被提出的算法。</p>
<p>它按内存容量将内存划分为等大小的两块，每次只使用其中一块，当这一块内存满了之后，便将其中存活的对象移至另一块内存上去，同时把已使用的内存清理掉。</p>
<p>这种算法实现简单，内存效率高，不易产生碎片，但同时也带来了一个问题，那就是可用内存被压缩到了原来的一半，且当存活对象过多时，其算法效率又会大大降低。</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/clipboard20230301026.png" alt="img" loading="lazy"></figure>
<h5 id="分代收集算法">分代收集算法</h5>
<p>此算法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域。</p>
<p>一般情况下，会将GC堆划分为老年代（Tenured/Old Generation）和新生代（Young Generation）。</p>
<p>老年代的特点是每次需要回收的对象很少，新生代则与之相反，因此可以根据不同的区域选择不同的算法。</p>
<p>新生代由于需要经常进行垃圾回收，所以可以采用复制算法（一般会将其再次划分为Eden，From Survivor以及To Survivor三个区域，比例为8:1:1（实际调优需要根据具体的业务调整））。</p>
<p>老年代则一般采用标记复制算法或者标记整理算法，可根据具体场景指定。</p>
<h3 id="gc垃圾收集器">GC垃圾收集器</h3>
<h4 id="serial垃圾收集器单线程复制算法">Serial垃圾收集器（单线程，复制算法）</h4>
<p>Serial是最基本的垃圾收集器，使用复制算法。JDK1.3.1之前，它是新生代唯一的垃圾收集器。</p>
<p>Serial是一个单线程的收集器，它不但只会用一个CPU或一条线程去完成垃圾收集工作，并且在进行垃圾收集的过程中，还要暂停其他所有线程（stop the world），直到垃圾收集结束。</p>
<p>Serial在执行时虽然会暂停其他所有线程，但其简单高效，对于限定单个CPU的环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率。</p>
<p>因此，Serial依旧是java虚拟机运行在Client模式下新生代的默认垃圾收集器。</p>
<h4 id="parnew垃圾收集器serial-多线程">ParNew垃圾收集器（serial + 多线程）</h4>
<p>ParNew其实是Serial收集器的多线程版本，除了多线程之外，其余与Serial完全一致。</p>
<p>ParNew默认开启和CPU数目相同的线程数，可以通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数。</p>
<p>相较于Seria而言，ParNew是java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p>
<h4 id="parallel-scavenge垃圾收集器多线程复制算法高效">Parallel Scavenge垃圾收集器（多线程复制算法，高效）</h4>
<p>Parallel Scavenge 是一个新生代垃圾收集器，使用复制算法，且为多线程。其重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU用于运行用户代码时间/CPU总消耗时间，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））。</p>
<p>高吞吐量可以最高效率的利用CPU时间，尽快地完成程序的运行任务，主要适用于在后台运算，而不需要太多交互的任务。</p>
<p>自适应调节策略也是Parallel Scavenge与ParNew的一个重要区别。</p>
<h4 id="serial-old垃圾收集器单线程标记整理算法">Serial Old垃圾收集器（单线程，标记整理算法）</h4>
<p>Serial Old是Serial垃圾收集器的老年代版本，它同样是单线程的，使用的算法为标记整理。Serial Old是java虚拟机运行在Client模式下老年代的默认垃圾收集器。</p>
<p>其在Server模式下，主要有两个用途：</p>
<p>1、在JDK1.5之前版本与新生代的Parallel Scavenge收集器搭配使用。</p>
<p>2、作为老年代中CMS的后备垃圾收集器。</p>
<h4 id="parallel-old垃圾收集器多线程标记整理算法">Parallel Old垃圾收集器（多线程，标记整理算法）</h4>
<p>Parallel Old是Parallel Scavenge垃圾收集器的老年代版本，它同样是多线程的，使用的算法为标记整理（JDK1.6之后才提供）。</p>
<h4 id="cms垃圾收集器多线程标记清除算法">CMS垃圾收集器（多线程，标记清除算法）</h4>
<p>Concurrent Mark Sweep是一种老年代垃圾收集器，其主要目的是为了获取最短垃圾回收停顿时间（在交互过程中提高用户体验），使用的算法为标记清除。</p>
<p>CMS执行过程：</p>
<ol>
<li>初始标记：标记一下GC ROOTS能直接关联的对象，速度很快，需要暂停工作线程。</li>
<li>并发标记：进行GC ROOTS跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</li>
<li>重新标记：为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记录，需要暂停工作线程。</li>
<li>并发清除：清除GC ROOTS不可达对象，和用户线程一起工作，不需要暂停工作线程，由于耗时最长的并发标记和并发清除是与用户线程一起工作的，所以总体上来看，CMS收集过程与用户线程是并发执行的。</li>
</ol>
<h4 id="g1垃圾收集器多线程标记整理算法">G1垃圾收集器（多线程，标记整理算法）</h4>
<p>Garbage first是目前垃圾收集器理论发展的最前沿成果，相比于CMS收集器，G1最突出的两个改进为：</p>
<ol>
<li>基于标记整理算法，不会产生内存碎片。</li>
<li>可以非常精准的控制停顿时间，在不牺牲吞吐量的前提下，实现低停顿回收。</li>
</ol>
<p>G1避免全区域的垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。</p>
<p>区域划分和优先级区域回收机制，确保了G1可以在有限的时间内获得最高的垃圾收集效率。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java8新特性Stream&CompletableFuture]]></title>
        <id>https://philosopherzb.github.io/post/java8-xin-te-xing-streamandcompletablefuture/</id>
        <link href="https://philosopherzb.github.io/post/java8-xin-te-xing-streamandcompletablefuture/">
        </link>
        <updated>2021-02-17T07:16:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java8新特性，主要是Stream和CompletableFuture的常用例子</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/mountain-477832_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="stream">Stream</h2>
<pre><code>// 获取某个属性的和
System.out.println(personPojos.stream().mapToInt(PersonPojo::getCount).sum());
// 最大值
System.out.println(personPojos.stream().mapToInt(PersonPojo::getCount).max());
// 最小值
System.out.println(personPojos.stream().mapToInt(PersonPojo::getCount).min());
// 平均值
System.out.println(personPojos.stream().mapToInt(PersonPojo::getCount).average());

// 获取某个属性值最大的集合
Optional&lt;PersonPojo&gt; couponConfigOptional = personPojos.stream().
        filter(Objects::nonNull).
        filter(personPojo -&gt; StringUtils.isNotEmpty(personPojo.getEndTime())).
        max(Comparator.comparing(PersonPojo::getEndTime));
couponConfigOptional.ifPresent(personPojo -&gt; System.out.println(JSONObject.toJSONString(personPojo)));


// 以对象的某个属性分组
Map&lt;String, List&lt;PersonPojo&gt;&gt; resultMap = personPojos.stream().collect(Collectors.groupingBy(PersonPojo::getName));
System.out.println(JSONObject.toJSONString(resultMap));

// 以对象某个属性分组，同时只取列表中的第一条数据
Map&lt;String, PersonPojo&gt; resultMap = personPojos.stream().collect(Collectors.groupingBy(PersonPojo::getName,Collectors.collectingAndThen(Collectors.toList(), value-&gt;value.get(0)))))));
System.out.println(JSONObject.toJSONString(resultMap));

// 以对象的某个属性分组，并只汇总某一个属性字段
Map&lt;String, List&lt;String&gt;&gt; map = personPojos.stream().collect(Collectors.groupingBy(PersonPojo::getId, Collectors.mapping(PersonPojo::getName, Collectors.toList())));
System.out.println(JSONObject.toJSONString(map));

// 过滤不包含某个对象
List&lt;PersonPojo&gt; filters = personPojos.stream().filter(personPojo-&gt;!personPojos.contains(personPojo)).collect(Collectors.toList());
System.out.println(JSONObject.toJSONString(filters));

// 移除不在有效期内的数据
long currentTime = System.currentTimeMillis();
personPojos.removeIf(personPojo -&gt; currentTime &lt; personPojo.getStartTime().getTime() || currentTime &gt; personPojo.getEndTime().getTime());

// 获取某个字段作为新的list
List&lt;String&gt; names =personPojos.stream().map(PersonPojo::getName).collect(Collectors.toList());
System.out.println(JSONObject.toJSONString(names));

// 获取某个字段作为新的list，去重
List&lt;String&gt; distinctNames =personPojos.stream().map(PersonPojo::getName).distinct().collect(Collectors.toList());
System.out.println(JSONObject.toJSONString(distinctNames));

// 判断对象组中是否存在包含指定值的对象
boolean match = personPojos.stream().anyMatch(personPojo -&gt; &quot;zhangsan&quot;.equals(personPojo.getName()));
System.out.println(match);
// 判断对象组是否都是包含指定值的对象
boolean match2 = personPojos.stream().allMatch(personPojo -&gt; &quot;zhangsan&quot;.equals(personPojo.getName()));
System.out.println(match2);

//返回 对象集合以类属性一升序排序
list.stream().sorted(Comparator.comparing(类::属性一));

//返回 对象集合以类属性一降序排序 注意两种写法
list.stream().sorted(Comparator.comparing(类::属性一).reversed());//先以属性一升序,结果进行属性一降序
list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));//以属性一降序

//返回 对象集合以类属性一升序 属性二升序
list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));

//返回 对象集合以类属性一降序 属性二升序 注意两种写法
//先以属性一升序,升序结果进行属性一降序,再进行属性二升序
list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));
//先以属性一降序,再进行属性二升序
list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));

//返回 对象集合以类属性一降序 属性二降序 注意两种写法
//先以属性一升序,升序结果进行属性一降序,再进行属性二降序
list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二,Comparator.reverseOrder()));
//先以属性一降序,再进行属性二降序
list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二,Comparator.reverseOrder()));

//返回 对象集合以类属性一升序 属性二降序 注意两种写法
//先以属性一升序,升序结果进行属性一降序,再进行属性二升序,结果进行属性一降序属性二降序
list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二).reversed());
//先以属性一升序,再进行属性二降序
list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二,Comparator.reverseOrder()));

// 多属性分组
Map&lt;String, Map&lt;String, List&lt;PersonPojo&gt;&gt;&gt; mapMap = personPojos.stream()
        .collect(Collectors.groupingBy(PersonPojo::getId, Collectors.groupingBy(PersonPojo::getName)));
System.out.println(JSONObject.toJSONString(mapMap));

// 多个属性合成一个属性
Map&lt;String, List&lt;PersonPojo&gt;&gt; map = personPojos.stream().collect(Collectors.groupingBy(Test5::fetchGroupKey));
System.out.println(JSONObject.toJSONString(map));
private static String fetchGroupKey(PersonPojo p) {
    return p.getId() + &quot;_&quot; + p.getName();
}

</code></pre>
<h2 id="completablefuture">CompletableFuture</h2>
<pre><code>package com.philosopherzb.demo.test;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * @author philosopherZB
 * @date 2021/9/28
 */
public class Test10 {
    public static void main(String[] args) {
//        Test10.testThenAccept();
//        Test10.testThenRun();
//        Test10.testThenApply();
//        Test10.testThenCombine();
//        Test10.testThenCompose();
//        Test10.testApplyToEither();
//        Test10.testExceptionally();
//        Test10.testHandle();
        Test10.testAllOf();
//        Test10.testGet();
    }

    /**
     * 功能: 当前任务正常完成后执行，且当前任务的返回值可作为下个任务的入参；thenAccept本身并没有返回值
     * 样例: 接受第一个任务执行结果的字符串，并将其与第二个任务的字符串进行拼接操作
     */
    private static void testThenAccept() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;first&quot;);
        first.thenAccept(f -&gt; {
            System.out.println(&quot;accept firstFuture result: &quot; + f);
            System.out.println(&quot;Splicing result: &quot; + f + &quot;second&quot;);
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 当前任务正常完成后执行；thenRun本身并没有返回值
     * 样例: 异步顺序执行
     */
    private static void testThenRun() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(&quot;first&quot;);
            return &quot;first&quot;;
        });
        first.thenRun(() -&gt; System.out.println(&quot;result: &quot; + &quot;second&quot;)).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 当前任务正常完成后执行，且当前任务的返回值可作为下个任务的入参；thenApply本身有返回值
     * 样例: 接受第一个任务执行结果的字符串，并将其与第二个任务的字符串进行拼接操作，最后将结果与第三个任务的字符串拼接（多个任务串行）
     */
    private static void testThenApply() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;first&quot;);
        CompletableFuture&lt;String&gt; second = first.thenApply(f -&gt; {
            System.out.println(&quot;second accept firstFuture result: &quot; + f);
            System.out.println(&quot;second Splicing result: &quot; + f + &quot;second&quot;);
            return f + &quot;second&quot;;
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
        second.thenApply(s -&gt; {
            System.out.println(&quot;second.thenApply accept firstFuture result: &quot; + s);
            System.out.println(&quot;second.thenApply Splicing result: &quot; + s + &quot;third&quot;);
            return s + &quot;third&quot;;
        }).whenComplete((r, throwable) -&gt; {
            System.out.println(&quot;third result: &quot; + r);
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 处理两个CompletionStage的结果并进行返回；thenCombine 本身有返回值
     * 样例: 拼接字符串
     */
    private static void testThenCombine() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;first&quot;);
        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; &quot;second&quot;);
        // 有返回值
        first.thenCombine(second, (f, s) -&gt; f + s).whenComplete((r, throwable) -&gt; {
            System.out.println(&quot;thenCombine result: &quot; + r);
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
        // 无返回值
        first.thenAcceptBoth(second, (f, s) -&gt; {
            System.out.println(&quot;thenAcceptBoth result: &quot; + f + s);
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
        // 无返回值, 在两个任务执行后执行
        first.runAfterBoth(second, () -&gt; {
            System.out.println(&quot;runAfterBoth result: &quot;);
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 处理两个CompletionStage的结果并进行返回, 与thenApply类似，不过lambda接受的是一个CompletableFuture；thenCompose 本身有返回值
     * 样例: 拼接字符串
     */
    private static void testThenCompose() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;first&quot;);
        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; &quot;second&quot;);
        // 有返回值
        first.thenCompose(f -&gt; second.thenApply(s -&gt; f + s)).whenComplete((r, throwable) -&gt; {
            System.out.println(&quot;thenCompose result: &quot; + r);
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 运行两个CompletionStage，并将最先处理结束的结果返回；applyToEither 本身有返回值
     * 样例: 返回最快处理结果
     */
    private static void testApplyToEither() {
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;first-sleep-1000&quot;;
        });
        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;second-sleep-2000&quot;;
        });
        // 获取一下返回值，否则以下代码不会执行
        System.out.println(&quot;=====&gt;&quot; + second.join());
        // 有返回值
        CompletableFuture&lt;String&gt; third = first.applyToEither(second, s -&gt; s).whenComplete((r, throwable) -&gt; {
            System.out.println(&quot;applyToEither result: &quot; + r);
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
        // 无返回值
        first.acceptEither(second, s -&gt; {
            System.out.println(&quot;acceptEither result: &quot; + s);
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
        // 无返回值, 在两个任务执行后执行
        first.runAfterEither(second, () -&gt; {
            System.out.println(&quot;runAfterEither result: &quot;);
        }).whenComplete((aVoid, throwable) -&gt; {
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        });
    }

    /**
     * 功能: 处理运行时异常，并进行额外的补偿操作（类似于try catch）；exceptionally 本身有返回值
     * 样例: 处理异常
     */
    private static void testExceptionally() {
        // 发生异常，thenApply不会执行（thenApply必须在程序正常运行后才会执行）
        CompletableFuture.supplyAsync(() -&gt; &quot;result: &quot; + (3 / 0))
                .thenApply(s -&gt; {
                    System.out.println(&quot;first not running: &quot; + s);
                    return s;
                })
                .exceptionally(throwable -&gt; {
                    System.out.println(&quot;first e: &quot; + throwable.getLocalizedMessage());
                    return &quot;first occur exception&quot;;
                })
                .whenComplete((r, throwable) -&gt; {
                    System.out.println(&quot;first exceptionally result: &quot; + r);
                    if (throwable != null) {
                        System.out.println(throwable.getLocalizedMessage());
                    }
                });
        // 正常运行，thenApply执行
        CompletableFuture.supplyAsync(() -&gt; &quot;result: &quot; + (3 / 1))
                .thenApply(s -&gt; {
                    System.out.println(&quot;second running: &quot; + s);
                    return s;
                })
                .exceptionally(throwable -&gt; {
                    System.out.println(&quot;second e: &quot; + throwable.getLocalizedMessage());
                    return &quot;second occur exception&quot;;
                })
                .whenComplete((r, throwable) -&gt; {
                    System.out.println(&quot;second exceptionally result: &quot; + r);
                    if (throwable != null) {
                        System.out.println(throwable.getLocalizedMessage());
                    }
                });
    }

    /**
     * 功能: handle类似于whenComplete，区别在于：handle 有返回值， whenComplete 无返回值
     * 样例: 打印返回值
     */
    private static void testHandle() {
        // 发生异常，thenApply不会执行（thenApply必须在程序正常运行后才会执行）
        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &quot;result: &quot; + (3 / 0))
                .thenApply(s -&gt; {
                    System.out.println(&quot;first not running: &quot; + s);
                    return s;
                })
                .exceptionally(throwable -&gt; {
                    System.out.println(&quot;first e: &quot; + throwable.getLocalizedMessage());
                    return &quot;first occur exception&quot;;
                })
                .handle((r, throwable) -&gt; {
                    System.out.println(&quot;first handle result: &quot; + r);
                    if (throwable != null) {
                        System.out.println(throwable.getLocalizedMessage());
                    }
                    return r;
                });
        // 正常运行，thenApply执行
        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; &quot;result: &quot; + (3 / 1))
                .thenApply(s -&gt; {
                    System.out.println(&quot;second running: &quot; + s);
                    return s;
                })
                .exceptionally(throwable -&gt; {
                    System.out.println(&quot;second e: &quot; + throwable.getLocalizedMessage());
                    return &quot;second occur exception&quot;;
                })
                .handle((r, throwable) -&gt; {
                    System.out.println(&quot;second handle result: &quot; + r);
                    if (throwable != null) {
                        System.out.println(throwable.getLocalizedMessage());
                    }
                    return r;
                });

        System.out.println(&quot;join result: &quot; + first.join());
        System.out.println(&quot;join result: &quot; + second.join());
    }

    /**
     * 功能: 所有任务完成后执行:allOf; 任意任务完成后执行：anyOf
     * 样例: 异步查询三个任务信息并返回
     */
    private static void testAllOf() {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        long start = System.currentTimeMillis();

        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(1000 + ThreadLocalRandom.current().nextInt(1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;first&quot;;
        }, executorService);
        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(1000 + ThreadLocalRandom.current().nextInt(1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;second&quot;;
        }, executorService);
        CompletableFuture&lt;String&gt; third = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(1000 + ThreadLocalRandom.current().nextInt(1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return &quot;third&quot;;
        }, executorService);
        // 所有任务完成后执行
        CompletableFuture.allOf(first, second, third).join();
        System.out.println(first.join() + second.join() + third.join());
        System.out.println(System.currentTimeMillis() - start);

        // 任意任务完成后执行
        CompletableFuture.anyOf(first, second, third).join();
        System.out.println(first.join() + second.join() + third.join());
        System.out.println(System.currentTimeMillis() - start);
    }

    /**
     * 获取返回值
     */
    private static void testGet() {
        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &quot;content&quot;).whenComplete(((result, throwable) -&gt; {
            System.out.println(&quot;result: &quot; + result);
            if (throwable != null) {
                System.out.println(throwable.getLocalizedMessage());
            }
        }));
        try {
            System.out.println(&quot;cf get: &quot; + cf.get());
            System.out.println(&quot;cf getWithTimeOut: &quot; + cf.get(1, TimeUnit.SECONDS));
            System.out.println(&quot;cf join: &quot; + cf.join());
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            e.printStackTrace();
        }

    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ArrayList源码解析(JDK8)]]></title>
        <id>https://philosopherzb.github.io/post/arraylist-yuan-ma-jie-xi-jdk8/</id>
        <link href="https://philosopherzb.github.io/post/arraylist-yuan-ma-jie-xi-jdk8/">
        </link>
        <updated>2021-02-06T06:58:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章主要简述Java中的ArrayList的源码以及其中如何进行扩容的逻辑分析（jdk8）</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/philosopherZB/blog-images/master/blogImg/road-1072821_1280.jpg" alt="" loading="lazy"></figure>
<h2 id="源码来自于jdk8">源码来自于JDK8</h2>
<pre><code>package java.util;

import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import sun.misc.SharedSecrets;

//其中实现了RandomAccess接口表示支持随机访问
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{
    //序列号
    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * 默认初始容量
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * 共享的空数组实例（用于空实例）
     * 当ArrayList(int initialCapacity)，ArrayList(Collection&lt;? extends E&gt; c)中的容量等于0的时候使用
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

    /**
     * 共享的空数组实例（用于默认大小的空实例）
     * 将其与EMPTY_ELEMENTDATA区分开来，主要是为了知道第一次添加元素的时候需要扩容多少
     * 用于ArrayList()构造器
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     * ArrayList保存有序元素的数组
     * ArraylList容量为数组容量
     * 任何空数组都使用 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * 当第一次添加元素的时候其容量将会扩容至 DEFAULT_CAPACITY（10）
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * ArrayList的大小（包含元素的数量）
     * @serial
     */
    private int size;

    /**
     * 带指定容量参数的构造器，如果元素数量较大的话，可以使用此构造器，防止频繁扩容造成的性能损失
     */
    public ArrayList(int initialCapacity) {
        //如果传入值大于0，则创建一个该容量大小的数组。
        if (initialCapacity &gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            //否则如果传入值等于0，则创建默认空数组
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            //如果小于0则抛出异常
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                    initialCapacity);
        }
    }

    /**
     * 默认构造函数，其初始容量为10（注意，这里一开始其实是一个空数组，只是当add时才会进行扩容至10的操作，一定程度上减小了内存消耗。）
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    /**
     * 构造一个包含指定集合元素的列表，元素顺序由集合的迭代器所返回。
     */
    public ArrayList(Collection&lt;? extends E&gt; c) {
        //集合转数组
        elementData = c.toArray();
        //指定集合含有元素
        if ((size = elementData.length) != 0) {
            // c.toArray可能不会返回Object[] (see 6260652)
            //使用反射进行运行时判断elementData是否属于Object[]
            if (elementData.getClass() != Object[].class)
                //拷贝数组
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // 由空数组代替
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }

    /**
     * 修改ArrayList容量为list的当前大小
     * 一个应用可以使用此操作来最小化一个ArrayList的存储
     */
    public void trimToSize() {
        modCount++;
        //如果当前数组元素个数小于数组容量
        if (size &lt; elementData.length) {
            //没有元素返回空数组，否则返回元素个数的数组。
            elementData = (size == 0)
                    ? EMPTY_ELEMENTDATA
                    : Arrays.copyOf(elementData, size);
        }
    }

    /**
     * 如果有必要去增加ArrayList的容量，请确保它至少可以容纳由最小容量参数指定的元素数量
     * @param   minCapacity   所需的最小容量
     */
    public void ensureCapacity(int minCapacity) {
        //默认最小容量，空数组以及默认大小10
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                // any size if not default element table
                ? 0
                // larger than default for default empty table. It's already
                // supposed to be at default size.
                : DEFAULT_CAPACITY;

        //如果传入容量大于最小容量，则进行扩容
        if (minCapacity &gt; minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
    }

    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        //如果elementData为默认空数组，则比较传入值与默认值（10），返回两者中的较大值
        //elementData为默认空数组指的是通过ArrayList()这个构造器创建的ArrayList对象
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        //返回传入值
        return minCapacity;
    }

    private void ensureCapacityInternal(int minCapacity) {
        //先通过calculateCapacity方法计算最终容量，以确认实际容量
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        //如果最终确认容量大于数组容量，则进行grow()扩容
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    }

    /**
     * 可分配数组最大大小
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * 增加ArrayList的容量，以确保它至少可以容纳由最小容量参数指定的元素数量
     * @param minCapacity 所需的最小容量
     */
    private void grow(int minCapacity) {
        // overflow-conscious code
        //oldCapacity表示旧容量
        int oldCapacity = elementData.length;
        //newCapacity表示新容量，计算规则为旧容量+旧容量的0.5，即旧容量的1.5倍。如果超过int的最大值会返回一个负数。
        //oldCapacity &gt;&gt; 1表示右移一位，对应除以2的1次方。
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        //如果新容量小于最小容量，则将最小容量赋值给新容量(有时手动扩容可能也会返回&lt;0，对应方法为ensureCapacity())
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        //如果新容量大于MAX_ARRAY_SIZE，则执行hugeCapacity(minCapacity)返回对应值
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        //复制旧数组到新容量数组中，完成扩容操作
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        //如果最小容量超过了int的最大值，minCapacity会是一个负数，此时抛出内存溢出错误
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        //比较最小容量是否大于MAX_ARRAY_SIZE，如果是则返回Integer.MAX_VALUE，否则返回MAX_ARRAY_SIZE
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
                Integer.MAX_VALUE :
                MAX_ARRAY_SIZE;
    }

    /**
     * 返回列表元素数
     */
    public int size() {
        return size;
    }

    /**
     * 如果列表不包含元素，返回true
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 如果列表包含指定元素，返回true
     */
    public boolean contains(Object o) {
        //返回此列表中指定元素第一次出现的索引，如果列表中不包含指定元素，则为-1
        return indexOf(o) &gt;= 0;
    }

    /**
     * 返回此列表中指定元素第一次出现的索引，如果列表中不包含指定元素，则为-1
     */
    public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i &lt; size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i &lt; size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * 返回此列表中指定元素最后一次出现的索引，如果列表中不包含指定元素，则为-1
     */
    public int lastIndexOf(Object o) {
        if (o == null) {
            for (int i = size-1; i &gt;= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = size-1; i &gt;= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * 返回ArrayList实例的一个浅拷贝，列表中的元素不会被拷贝
     */
    public Object clone() {
        try {
            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn't happen, since we are Cloneable
            throw new InternalError(e);
        }
    }

    /**
     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。
     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。
     * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。
     */
    public Object[] toArray() {
        return Arrays.copyOf(elementData, size);
    }

    /**
     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;
     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。
     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。
     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。
     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T[] toArray(T[] a) {
        if (a.length &lt; size)
            //创建一个新的运行时类型数组，内容为ArrayList数组的
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length &gt; size)
            a[size] = null;
        return a;
    }

    // 位置访问操作

    @SuppressWarnings(&quot;unchecked&quot;)
    E elementData(int index) {
        return (E) elementData[index];
    }

    /**
     * 返回此列表中指定位置的元素
     */
    public E get(int index) {
        //检查索引是否越界
        rangeCheck(index);

        return elementData(index);
    }

    /**
     * 用指定元素替换列表中的指定位置的元素
     */
    public E set(int index, E element) {
        //检查索引是否越界
        rangeCheck(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        return oldValue;
    }

    /**
     * 将指定元素追加到数组末尾
     */
    public boolean add(E e) {
        //添加之前先确认是否需要扩容
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //新加入的元素是添加在了数组的末尾，随后数组size自增。
        elementData[size++] = e;
        return true;
    }

    /**
     * 插入指定元素到此列表中的指定位置
     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //自己复制自己
        System.arraycopy(elementData, index, elementData, index + 1,
                size - index);
        elementData[index] = element;
        size++;
    }

    /**
     * 将列表中指定位置的元素移除，后续所有元素移到左端（从他们的索引中减去一个）
     */
    public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                    numMoved);
        elementData[--size] = null; //  清理工作交给GC

        return oldValue;
    }

    /**
     * 从列表中移除第一次出现的指定元素，如果不存在，则不更改
     */
    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index &lt; size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index &lt; size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

    /*
     * Private remove method that skips bounds checking and does not
     * return the value removed.
     */
    private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                    numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }

    /**
     * 移除列表中的所有元素，之后会返回一个空数组
     */
    public void clear() {
        modCount++;

        // clear to let GC do its work
        for (int i = 0; i &lt; size; i++)
            elementData[i] = null;

        size = 0;
    }

    /**
     * 将指定集合中的元素以Iterator返回的顺序，追加到列表末尾
     */
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }

    /**
     * 将指定集合中的元素以Iterator返回的顺序，插入到指定位置
     */
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                    numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }

    /**
     * 移除[fromIndex,toIndex)之间的元素，后续元素移到左端
     */
    protected void removeRange(int fromIndex, int toIndex) {
        modCount++;
        int numMoved = size - toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                numMoved);

        // clear to let GC do its work
        int newSize = size - (toIndex-fromIndex);
        for (int i = newSize; i &lt; size; i++) {
            elementData[i] = null;
        }
        size = newSize;
    }

    /**
     *检查给定索引是否在界限内。
     */
    private void rangeCheck(int index) {
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * add and addAll使用的rangeCheck
     */
    private void rangeCheckForAdd(int index) {
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * 返回 an IndexOutOfBoundsException 的细节信息
     */
    private String outOfBoundsMsg(int index) {
        return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;
    }

    /**
     * 从列表中移除指定集合包含的所有元素
     */
    public boolean removeAll(Collection&lt;?&gt; c) {
        Objects.requireNonNull(c);
        return batchRemove(c, false);
    }

    /**
     * 保留此列表中指定集合的所有元素
     */
    public boolean retainAll(Collection&lt;?&gt; c) {
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    }

    //批量移除
    private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
        final Object[] elementData = this.elementData;
        int r = 0, w = 0;
        boolean modified = false;
        try {
            for (; r &lt; size; r++)
                if (c.contains(elementData[r]) == complement)
                    elementData[w++] = elementData[r];
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            if (r != size) {
                System.arraycopy(elementData, r,
                        elementData, w,
                        size - r);
                w += size - r;
            }
            if (w != size) {
                // clear to let GC do its work
                for (int i = w; i &lt; size; i++)
                    elementData[i] = null;
                modCount += size - w;
                size = w;
                modified = true;
            }
        }
        return modified;
    }

    /**
     * 保存ArrayList状态到一个流中（即序列化）
     */
    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException{
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioural compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }

    /**
     * 从一个流中读取ArrayList（即反序列化）
     */
    private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        elementData = EMPTY_ELEMENTDATA;

        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in capacity
        s.readInt(); // ignored

        if (size &gt; 0) {
            // be like clone(), allocate array based upon size not capacity
            int capacity = calculateCapacity(elementData, size);
            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
            ensureCapacityInternal(size);

            Object[] a = elementData;
            // Read in all elements in the proper order.
            for (int i=0; i&lt;size; i++) {
                a[i] = s.readObject();
            }
        }
    }

    /**
     *  从列表中的指定位置开始，返回之后所有元素的列表迭代器（按正确的顺序）
     *  指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。
     *  返回的列表迭代器是fail-fast 。
     */
    public ListIterator&lt;E&gt; listIterator(int index) {
        if (index &lt; 0 || index &gt; size)
            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);
        return new ListItr(index);
    }

    /**
     * 返回列表中的包含所有元素的列表迭代器（按正确的顺序）。
     * 返回的列表迭代器是fail-fast 。
     */
    public ListIterator&lt;E&gt; listIterator() {
        return new ListItr(0);
    }

    /**
     * 以正确的顺序返回列表中的包含所有元素的迭代器。
     * 返回的迭代器是fail-fast 。
     */
    public Iterator&lt;E&gt; iterator() {
        return new Itr();
    }

    @Override
    public void forEach(Consumer&lt;? super E&gt; action) {
        Objects.requireNonNull(action);
        final int expectedModCount = modCount;
        @SuppressWarnings(&quot;unchecked&quot;)
        final E[] elementData = (E[]) this.elementData;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
            action.accept(elementData[i]);
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }


    @Override
    public boolean removeIf(Predicate&lt;? super E&gt; filter) {
        Objects.requireNonNull(filter);
        // figure out which elements are to be removed
        // any exception thrown from the filter predicate at this stage
        // will leave the collection unmodified
        int removeCount = 0;
        final BitSet removeSet = new BitSet(size);
        final int expectedModCount = modCount;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
            @SuppressWarnings(&quot;unchecked&quot;)
            final E element = (E) elementData[i];
            if (filter.test(element)) {
                removeSet.set(i);
                removeCount++;
            }
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }

        // shift surviving elements left over the spaces left by removed elements
        final boolean anyToRemove = removeCount &gt; 0;
        if (anyToRemove) {
            final int newSize = size - removeCount;
            for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) {
                i = removeSet.nextClearBit(i);
                elementData[j] = elementData[i];
            }
            for (int k=newSize; k &lt; size; k++) {
                elementData[k] = null;  // Let gc do its work
            }
            this.size = newSize;
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
            modCount++;
        }

        return anyToRemove;
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void replaceAll(UnaryOperator&lt;E&gt; operator) {
        Objects.requireNonNull(operator);
        final int expectedModCount = modCount;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
            elementData[i] = operator.apply((E) elementData[i]);
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void sort(Comparator&lt;? super E&gt; c) {
        final int expectedModCount = modCount;
        Arrays.sort((E[]) elementData, 0, size, c);
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }
}

</code></pre>
<h2 id="扩容源码解析jdk8">扩容源码解析（JDK8）</h2>
<p>首先我们使用 ArrayList <code>&lt;String&gt;</code> list = new ArrayList&lt;&gt;(5)创建一个ArrayLsit，这表明创建的ArrayList初始容量为5.</p>
<pre><code>    //默认初始容量10
    private static final int DEFAULT_CAPACITY = 10;
    //一个空的默认对象数组，当ArrayList(int initialCapacity)，ArrayList(Collection&lt;? extends E&gt; c)中的容量等于0的时候使用
    private static final Object[] EMPTY_ELEMENTDATA = {};
    //一个空的默认对象数组，用于ArrayList()构造器
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    //一个对象数组，transient表示不能序列化
    transient Object[] elementData;
    //数组大小
    private int size;

    //以传入的容量构造一个空的list
    public ArrayList(int initialCapacity) {
        //如果传入值大于0，则创建一个该容量大小的数组。
        if (initialCapacity &gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            //否则如果传入值等于0，则创建默认空数组
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            //如果小于0则抛出异常
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                    initialCapacity);
        }
    }

</code></pre>
<p>接着我们使用add方法添加一个字符串到该list中，list.add(&quot;Test&quot;)。进入add源码会发现，真正的扩容是发生在add操作之前的。</p>
<pre><code>    //默认添加在数组末尾
    public boolean add(E e) {
        //添加之前先确认是否需要扩容
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //新加入的元素是添加在了数组的末尾，随后数组size自增。
        elementData[size++] = e;
        return true;
    }

</code></pre>
<p>进入ensureCapacityInternal()方法查看对应源码如下：</p>
<pre><code>    private void ensureCapacityInternal(int minCapacity) {
        //先通过calculateCapacity方法计算最终容量，以确认实际容量
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

</code></pre>
<p>到这一步，我们需要先进入calculateCapacity()方法看看他是如何计算最后容量的，源码如下：</p>
<pre><code>    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        //如果elementData为默认空数组，则比较传入值与默认值（10），返回两者中的较大值
        //elementData为默认空数组指的是通过ArrayList()这个构造器创建的ArrayList对象
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        //返回传入值
        return minCapacity;
    }

</code></pre>
<p>现在我们确认了最终容量，那么进入ensureExplicitCapacity，查看源码如下：</p>
<pre><code>    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;
        // overflow-conscious code
        //如果最终确认容量大于数组容量，则进行grow()扩容
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    }

</code></pre>
<p>可以看到，只有当最终容量大于数组容量时才会进行扩容。那么以我们上面的例子而言具体分析如下：</p>
<ol>
<li>首先因为我们创建的时候就赋了初始容量5，所以elementData.length = 5。</li>
<li>当我们add第一个元素的时候，minCapacity是等于size + 1 = 1的。</li>
<li>此时minCapacity - elementData.length &gt; 0条件不成立，所以不会进入grow(minCapacity)方法进行扩容。</li>
<li>以此类推，只有添加到第五个元素的时候，minCapacity = 6 大于 elementData.length = 5，这时就会进入grow(minCapacity)方法进行扩容。</li>
</ol>
<p>grow()以及hugeCapacity()源码如下：</p>
<pre><code>    //可分配的最大数组大小
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    //扩容
    private void grow(int minCapacity) {
        // overflow-conscious code
        //oldCapacity表示旧容量
        int oldCapacity = elementData.length;
        //newCapacity表示新容量，计算规则为旧容量+旧容量的0.5，即旧容量的1.5倍。如果超过int的最大值会返回一个负数。
        //oldCapacity &gt;&gt; 1表示右移一位，对应除以2的1次方。
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        //如果新容量小于最小容量，则将最小容量赋值给新容量(有时手动扩容可能也会返回&lt;0，对应方法为ensureCapacity())
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        //如果新容量大于MAX_ARRAY_SIZE，则执行hugeCapacity(minCapacity)返回对应值
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        //复制旧数组到新容量数组中，完成扩容操作
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        //如果最小容量超过了int的最大值，minCapacity会是一个负数，此时抛出内存溢出错误
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        //比较最小容量是否大于MAX_ARRAY_SIZE，如果是则返回Integer.MAX_VALUE，否则返回MAX_ARRAY_SIZE
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
                Integer.MAX_VALUE :
                MAX_ARRAY_SIZE;
    }

</code></pre>
]]></content>
    </entry>
</feed>